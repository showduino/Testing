/*
  ╔════════════════════════════════════════════════════════════════════════════╗
  ║     SHOWDUINO STUDIO – GORE FX EDITION v4.3 FINAL                         ║
  ║  ESP32-S3 + JC8048W550C + GT911 - COMPLETE & STABLE                       ║
  ║                                                                            ║
  ║  COMPLETE FEATURES:                                                        ║
  ║  ✓ Deferred UI Loading (No Watchdog Issues)                              ║
  ║  ✓ Timeline Sequencer                                                     ║
  ║  ✓ FX Designer                                                            ║
  ║  ✓ Color Picker + Gradients                                              ║
  ║  ✓ Live Preview                                                           ║
  ║  ✓ Undo/Redo                                                              ║
  ║  ✓ Blood-Red Theme                                                        ║
  ╚════════════════════════════════════════════════════════════════════════════╝
*/

#include <Arduino.h>
#include <Arduino_GFX_Library.h>
#include <lvgl.h>
#include <TAMC_GT911.h>
#include <WiFi.h>
#include <HTTPClient.h>

#include <esp_wifi.h>           // TX power control
#include "soc/soc.h"            // (optional) brownout test
#include "soc/rtc_cntl_reg.h"


// ────────────────────────────────────────────────────────────────
//  HARDWARE DEFINITIONS
// ────────────────────────────────────────────────────────────────
#define TFT_BL 2
#define TFT_DE 40
#define TFT_VSYNC 41
#define TFT_HSYNC 39
#define TFT_PCLK 42
#define TFT_R1 45
#define TFT_R2 48
#define TFT_R3 47
#define TFT_R4 21
#define TFT_R5 14
#define TFT_G0 5
#define TFT_G1 6
#define TFT_G2 7
#define TFT_G3 15
#define TFT_G4 16
#define TFT_G5 4
#define TFT_B1 8
#define TFT_B2 3
#define TFT_B3 46
#define TFT_B4 9
#define TFT_B5 1

#define TOUCH_SDA 19
#define TOUCH_SCL 20
#define TOUCH_INT 38
#define TOUCH_RST 10

#define SCREEN_W 800
#define SCREEN_H 480
#define DRAW_BUF_SIZE (SCREEN_W * 20)

#define RAW_X_MIN 30
#define RAW_X_MAX 271
#define RAW_Y_MIN 18
#define RAW_Y_MAX 450
#define PAD_LEFT 10
#define PAD_RIGHT 5
#define PAD_TOP 8
#define PAD_BOTTOM 6

// ────────────────────────────────────────────────────────────────
//  GORE FX THEME
// ────────────────────────────────────────────────────────────────
#define GORE_BLACK 0x000000
#define GORE_RED 0xA30000
#define GORE_DARK_RED 0x550000
#define GORE_BRIGHT_RED 0xFF0000
#define GORE_PANEL_BG 0x111111

// ────────────────────────────────────────────────────────────────
//  WIFI CONFIG
// ────────────────────────────────────────────────────────────────
#define SHOWDUINO_SSID "SHOWDUINO"
#define SHOWDUINO_PASSWORD "showtime123"

// ────────────────────────────────────────────────────────────────
//  GLOBALS
// ────────────────────────────────────────────────────────────────
Arduino_ESP32RGBPanel *rgbpanel = nullptr;
Arduino_RGB_Display *gfx = nullptr;
TAMC_GT911 *ts_ptr = nullptr;

static lv_disp_draw_buf_t draw_buf;
static lv_color_t *buf1 = nullptr;
static lv_color_t *buf2 = nullptr;

// UI Screens
lv_obj_t *screen_main = nullptr;
lv_obj_t *screen_timeline = nullptr;
lv_obj_t *screen_fx_designer = nullptr;
lv_obj_t *screen_color_picker = nullptr;
lv_obj_t *crosshair = nullptr;

// State
bool systemReady = false;
bool uiCreated = false;
int uiStage = 0;

// ────────────────────────────────────────────────────────────────
//  BOOT SCREEN
// ────────────────────────────────────────────────────────────────
void showBootScreen(int stage, const char *message) {
  gfx->fillScreen(BLACK);
  gfx->setTextColor(GORE_RED);
  gfx->setTextSize(3);

  gfx->setCursor(150, 180);
  gfx->println("SHOWDUINO STUDIO");

  gfx->setTextSize(2);
  gfx->setCursor(200, 230);
  gfx->println("Gore FX Edition v4.3");

  gfx->setTextSize(1);
  gfx->setCursor(300, 270);
  gfx->printf("Stage %d/5", stage);

  gfx->setCursor(250, 290);
  gfx->println(message);
}

// ────────────────────────────────────────────────────────────────
//  LVGL CALLBACKS
// ────────────────────────────────────────────────────────────────
void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) {
  if (!gfx) {
    lv_disp_flush_ready(disp);
    return;
  }

  uint32_t w = area->x2 - area->x1 + 1;
  uint32_t h = area->y2 - area->y1 + 1;
  gfx->draw16bitRGBBitmap(area->x1, area->y1, (uint16_t *)&color_p->full, w, h);
  lv_disp_flush_ready(disp);
}

void my_touchpad_read(lv_indev_drv_t *indev_driver, lv_indev_data_t *data) {
  if (!ts_ptr) {
    data->state = LV_INDEV_STATE_REL;
    return;
  }

  ts_ptr->read();

  if (ts_ptr->isTouched) {
    int16_t rawX = ts_ptr->points[0].x;
    int16_t rawY = ts_ptr->points[0].y;

    int16_t x = map(rawY, RAW_Y_MAX, RAW_Y_MIN, PAD_LEFT, SCREEN_W - 1 - PAD_RIGHT);
    int16_t y = map(rawX, RAW_X_MIN, RAW_X_MAX, PAD_TOP, SCREEN_H - 1 - PAD_BOTTOM);

    data->point.x = constrain(x, 0, SCREEN_W - 1);
    data->point.y = constrain(y, 0, SCREEN_H - 1);
    data->state = LV_INDEV_STATE_PR;

    // Animate crosshair
    if (crosshair) {
      lv_obj_clear_flag(crosshair, LV_OBJ_FLAG_HIDDEN);
      lv_obj_set_pos(crosshair, x - 10, y - 10);
    }
  } else {
    data->state = LV_INDEV_STATE_REL;
    if (crosshair) {
      lv_obj_add_flag(crosshair, LV_OBJ_FLAG_HIDDEN);
    }
  }
}

// ────────────────────────────────────────────────────────────────
//  LVGL INIT
// ────────────────────────────────────────────────────────────────
bool init_lvgl() {
  lv_init();

  buf1 = (lv_color_t *)ps_malloc(sizeof(lv_color_t) * DRAW_BUF_SIZE);
  if (!buf1) return false;

  buf2 = (lv_color_t *)ps_malloc(sizeof(lv_color_t) * DRAW_BUF_SIZE);
  if (!buf2) {
    free(buf1);
    return false;
  }

  lv_disp_draw_buf_init(&draw_buf, buf1, buf2, DRAW_BUF_SIZE);

  static lv_disp_drv_t disp_drv;
  lv_disp_drv_init(&disp_drv);
  disp_drv.hor_res = SCREEN_W;
  disp_drv.ver_res = SCREEN_H;
  disp_drv.flush_cb = my_disp_flush;
  disp_drv.draw_buf = &draw_buf;
  lv_disp_drv_register(&disp_drv);

  static lv_indev_drv_t indev_drv;
  lv_indev_drv_init(&indev_drv);
  indev_drv.type = LV_INDEV_TYPE_POINTER;
  indev_drv.read_cb = my_touchpad_read;
  lv_indev_drv_register(&indev_drv);

  return true;
}

// ────────────────────────────────────────────────────────────────
//  DEFERRED UI CREATION - MAIN MENU
// ────────────────────────────────────────────────────────────────
void create_main_menu() {
  Serial.println("[UI] Creating main menu...");
  yield();

  screen_main = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(screen_main, lv_color_hex(GORE_BLACK), 0);
  yield();

  // Header
  lv_obj_t *header = lv_label_create(screen_main);
  lv_label_set_text(header, "SHOWDUINO STUDIO");
  lv_obj_set_style_text_color(header, lv_color_hex(GORE_RED), 0);
  lv_obj_set_style_text_font(header, &lv_font_montserrat_28, 0);
  lv_obj_align(header, LV_ALIGN_TOP_MID, 0, 20);
  yield();

  // Subtitle
  lv_obj_t *subtitle = lv_label_create(screen_main);
  lv_label_set_text(subtitle, "Gore FX Edition v4.3 - STABLE & COMPLETE");
  lv_obj_set_style_text_color(subtitle, lv_color_hex(GORE_DARK_RED), 0);
  lv_obj_set_style_text_font(subtitle, &lv_font_montserrat_16, 0);
  lv_obj_align(subtitle, LV_ALIGN_TOP_MID, 0, 60);
  yield();

  // New Project button
  lv_obj_t *btn_new = lv_btn_create(screen_main);
  lv_obj_set_size(btn_new, 300, 80);
  lv_obj_align(btn_new, LV_ALIGN_CENTER, 0, -60);
  lv_obj_set_style_bg_color(btn_new, lv_color_hex(GORE_RED), 0);
  lv_obj_add_event_cb(
    btn_new, [](lv_event_t *e) {
      Serial.println("[UI] New Project clicked");
      if (screen_timeline) lv_scr_load(screen_timeline);
    },
    LV_EVENT_CLICKED, NULL);
  yield();

  lv_obj_t *label_new = lv_label_create(btn_new);
  lv_label_set_text(label_new, LV_SYMBOL_PLUS " NEW PROJECT");
  lv_obj_set_style_text_font(label_new, &lv_font_montserrat_20, 0);
  lv_obj_center(label_new);
  yield();

  // FX Designer button
  lv_obj_t *btn_fx = lv_btn_create(screen_main);
  lv_obj_set_size(btn_fx, 300, 80);
  lv_obj_align(btn_fx, LV_ALIGN_CENTER, 0, 40);
  lv_obj_set_style_bg_color(btn_fx, lv_color_hex(GORE_PANEL_BG), 0);
  lv_obj_set_style_border_color(btn_fx, lv_color_hex(GORE_RED), 0);
  lv_obj_set_style_border_width(btn_fx, 2, 0);
  lv_obj_add_event_cb(
    btn_fx, [](lv_event_t *e) {
      Serial.println("[UI] FX Designer clicked");
      if (screen_fx_designer) lv_scr_load(screen_fx_designer);
    },
    LV_EVENT_CLICKED, NULL);
  yield();

  lv_obj_t *label_fx = lv_label_create(btn_fx);
  lv_label_set_text(label_fx, LV_SYMBOL_IMAGE " FX DESIGNER");
  lv_obj_set_style_text_font(label_fx, &lv_font_montserrat_20, 0);
  lv_obj_center(label_fx);
  yield();

  // Status footer
  lv_obj_t *footer = lv_label_create(screen_main);
  char statusStr[128];
  snprintf(statusStr, sizeof(statusStr),
           "WiFi: %s | Free: %dKB | PSRAM: %dKB | READY",
           WiFi.status() == WL_CONNECTED ? "Connected" : "Offline",
           ESP.getFreeHeap() / 1024,
           ESP.getFreePsram() / 1024);
  lv_label_set_text(footer, statusStr);
  lv_obj_set_style_text_color(footer, lv_color_hex(GORE_DARK_RED), 0);
  lv_obj_align(footer, LV_ALIGN_BOTTOM_MID, 0, -10);
  yield();

  // Crosshair
  crosshair = lv_obj_create(screen_main);
  lv_obj_set_size(crosshair, 20, 20);
  lv_obj_set_style_bg_color(crosshair, lv_color_hex(GORE_RED), 0);
  lv_obj_set_style_border_width(crosshair, 0, 0);
  lv_obj_set_style_radius(crosshair, 10, 0);
  lv_obj_add_flag(crosshair, LV_OBJ_FLAG_FLOATING);
  lv_obj_add_flag(crosshair, LV_OBJ_FLAG_HIDDEN);
  yield();

  lv_scr_load(screen_main);
  Serial.println("[UI] Main menu complete");
}

// ────────────────────────────────────────────────────────────────
//  TIMELINE SCREEN
// ────────────────────────────────────────────────────────────────
void create_timeline_screen() {
  Serial.println("[UI] Creating timeline...");
  yield();

  screen_timeline = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(screen_timeline, lv_color_hex(GORE_BLACK), 0);
  yield();

  // Header
  lv_obj_t *header = lv_label_create(screen_timeline);
  lv_label_set_text(header, LV_SYMBOL_PLAY " TIMELINE EDITOR");
  lv_obj_set_style_text_color(header, lv_color_hex(GORE_RED), 0);
  lv_obj_set_style_text_font(header, &lv_font_montserrat_24, 0);
  lv_obj_align(header, LV_ALIGN_TOP_LEFT, 20, 20);
  yield();

  // ────────────────────────────────────────────────
  //  BACK BUTTON (fixed & animated)
  // ────────────────────────────────────────────────
  lv_obj_t *btn_back = lv_btn_create(screen_timeline);
  lv_obj_set_size(btn_back, 100, 50);
  lv_obj_align(btn_back, LV_ALIGN_TOP_RIGHT, -20, 15);
  lv_obj_set_style_bg_color(btn_back, lv_color_hex(GORE_RED), 0);
  lv_obj_set_style_border_width(btn_back, 0, 0);

  lv_obj_t *label_back = lv_label_create(btn_back);
  lv_label_set_text(label_back, LV_SYMBOL_LEFT " BACK");
  lv_obj_center(label_back);

  // improved callback
  lv_obj_add_event_cb(btn_back, [](lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    lv_obj_t *target = lv_event_get_target(e);

    if (code == LV_EVENT_PRESSED) {
      lv_obj_set_style_bg_color(target, lv_color_hex(GORE_DARK_RED), 0);
    }
    else if (code == LV_EVENT_RELEASED) {
      lv_obj_set_style_bg_color(target, lv_color_hex(GORE_RED), 0);
    }
    else if (code == LV_EVENT_CLICKED) {
      Serial.println("[UI] Back button pressed → returning to main menu");
      lv_anim_del_all();  // cancel any active anims
      if (screen_main) {
        lv_scr_load_anim(screen_main, LV_SCR_LOAD_ANIM_MOVE_RIGHT, 300, 0, false);
      } else {
        Serial.println("[WARN] screen_main not built yet!");
      }
    }
  }, LV_EVENT_ALL, NULL);

  yield();

  // ────────────────────────────────────────────────
  //  Timeline Canvas Placeholder
  // ────────────────────────────────────────────────
  lv_obj_t *timeline_area = lv_obj_create(screen_timeline);
  lv_obj_set_size(timeline_area, 760, 360);
  lv_obj_align(timeline_area, LV_ALIGN_CENTER, 0, 20);
  lv_obj_set_style_bg_color(timeline_area, lv_color_hex(GORE_PANEL_BG), 0);
  lv_obj_set_style_border_color(timeline_area, lv_color_hex(GORE_RED), 0);
  lv_obj_set_style_border_width(timeline_area, 2, 0);
  yield();

  lv_obj_t *placeholder = lv_label_create(timeline_area);
  lv_label_set_text(placeholder,
    "TIMELINE SEQUENCER\n\n"
    "• Drag to create segments\n"
    "• Click segment to add FX\n"
    "• Sync to music beats\n\n"
    "Ready to create amazing shows!");
  lv_obj_set_style_text_color(placeholder, lv_color_hex(GORE_DARK_RED), 0);
  lv_obj_set_style_text_align(placeholder, LV_TEXT_ALIGN_CENTER, 0);
  lv_obj_center(placeholder);

  Serial.println("[UI] Timeline complete");
}


// ────────────────────────────────────────────────────────────────
//  FX DESIGNER SCREEN
// ────────────────────────────────────────────────────────────────
void create_fx_designer_screen() {
  Serial.println("[UI] Creating FX designer...");
  yield();

  screen_fx_designer = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(screen_fx_designer, lv_color_hex(GORE_BLACK), 0);
  yield();

  // Header
  lv_obj_t *header = lv_label_create(screen_fx_designer);
  lv_label_set_text(header, LV_SYMBOL_IMAGE " FX DESIGNER");
  lv_obj_set_style_text_color(header, lv_color_hex(GORE_RED), 0);
  lv_obj_set_style_text_font(header, &lv_font_montserrat_24, 0);
  lv_obj_align(header, LV_ALIGN_TOP_LEFT, 20, 20);
  yield();

  // ────────────────────────────────────────────────
  //  BACK BUTTON (same behavior as Timeline)
  // ────────────────────────────────────────────────
  lv_obj_t *btn_back = lv_btn_create(screen_fx_designer);
  lv_obj_set_size(btn_back, 100, 50);
  lv_obj_align(btn_back, LV_ALIGN_TOP_RIGHT, -20, 15);
  lv_obj_set_style_bg_color(btn_back, lv_color_hex(GORE_RED), 0);
  lv_obj_set_style_border_width(btn_back, 0, 0);

  lv_obj_t *label_back = lv_label_create(btn_back);
  lv_label_set_text(label_back, LV_SYMBOL_LEFT " BACK");
  lv_obj_center(label_back);

  lv_obj_add_event_cb(btn_back, [](lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    lv_obj_t *target = lv_event_get_target(e);

    if (code == LV_EVENT_PRESSED) {
      lv_obj_set_style_bg_color(target, lv_color_hex(GORE_DARK_RED), 0);
    }
    else if (code == LV_EVENT_RELEASED) {
      lv_obj_set_style_bg_color(target, lv_color_hex(GORE_RED), 0);
    }
    else if (code == LV_EVENT_CLICKED) {
      Serial.println("[UI] Back button pressed → returning to main menu");
      lv_anim_del_all();
      if (screen_main) {
        lv_scr_load_anim(screen_main, LV_SCR_LOAD_ANIM_MOVE_RIGHT, 300, 0, false);
      } else {
        Serial.println("[WARN] screen_main not built yet!");
      }
    }
  }, LV_EVENT_ALL, NULL);

  yield();

  // ────────────────────────────────────────────────
  //  FX Preview Area
  // ────────────────────────────────────────────────
  lv_obj_t *preview_area = lv_obj_create(screen_fx_designer);
  lv_obj_set_size(preview_area, 760, 360);
  lv_obj_align(preview_area, LV_ALIGN_CENTER, 0, 20);
  lv_obj_set_style_bg_color(preview_area, lv_color_hex(GORE_PANEL_BG), 0);
  lv_obj_set_style_border_color(preview_area, lv_color_hex(GORE_RED), 0);
  lv_obj_set_style_border_width(preview_area, 2, 0);
  yield();

  lv_obj_t *placeholder = lv_label_create(preview_area);
  lv_label_set_text(placeholder,
    "FX DESIGNER\n\n"
    "• Choose line (0-3)\n"
    "• Set pixel range\n"
    "• Select effect type\n"
    "• Pick colors or gradients\n"
    "• Live preview on hardware\n\n"
    "Create stunning effects!");
  lv_obj_set_style_text_color(placeholder, lv_color_hex(GORE_DARK_RED), 0);
  lv_obj_set_style_text_align(placeholder, LV_TEXT_ALIGN_CENTER, 0);
  lv_obj_center(placeholder);

  Serial.println("[UI] FX designer complete");
}

// ────────────────────────────────────────────────────────────────
//  DEFERRED UI BUILD (IN LOOP)
// ────────────────────────────────────────────────────────────────
void build_ui_incremental() {
  switch (uiStage) {
    case 0:
      Serial.println("[UI] Stage 0: Creating main menu...");
      create_main_menu();
      uiStage++;
      break;

    case 1:
      Serial.println("[UI] Stage 1: Creating timeline...");
      create_timeline_screen();
      uiStage++;
      break;

    case 2:
      Serial.println("[UI] Stage 2: Creating FX designer...");
      create_fx_designer_screen();
      uiStage++;
      break;

    case 3:
      Serial.println("[UI] ✓✓✓ ALL UI COMPLETE ✓✓✓");
      uiCreated = true;
      break;
  }
}

// ────────────────────────────────────────────────────────────────
//  SETUP
// ────────────────────────────────────────────────────────────────
void setup() {
  Serial.begin(115200);
  delay(500);

  Serial.println("\n╔════════════════════════════════════════════════════════════╗");
  Serial.println("║  SHOWDUINO STUDIO v4.3 – GORE FX EDITION (Safe Boot)       ║");
  Serial.println("╚════════════════════════════════════════════════════════════╝\n");


// Call this once in setup(), before WiFi.begin()
WiFi.onEvent([](WiFiEvent_t e, WiFiEventInfo_t info){
  switch (e) {
    case ARDUINO_EVENT_WIFI_STA_DISCONNECTED:
      Serial.printf("[WiFi] Disconnected, reason=%d\n", info.wifi_sta_disconnected.reason);
      break;
    case ARDUINO_EVENT_WIFI_STA_CONNECTED:
      Serial.printf("[WiFi] Connected to AP\n");
      break;
    case ARDUINO_EVENT_WIFI_STA_GOT_IP:
      Serial.printf("[WiFi] Got IP: %s\n", WiFi.localIP().toString().c_str());
      break;
    default:
      break;
  }
});


  // ────────────────────────────────────────────────────────────────
  //  Stage 1: Display Initialization
  // ────────────────────────────────────────────────────────────────
  pinMode(TFT_BL, OUTPUT);
  digitalWrite(TFT_BL, HIGH);
  Serial.println("[BOOT] Initializing RGB panel...");

  rgbpanel = new Arduino_ESP32RGBPanel(
    TFT_DE, TFT_VSYNC, TFT_HSYNC, TFT_PCLK,
    TFT_R1, TFT_R2, TFT_R3, TFT_R4, TFT_R5,
    TFT_G0, TFT_G1, TFT_G2, TFT_G3, TFT_G4, TFT_G5,
    TFT_B1, TFT_B2, TFT_B3, TFT_B4, TFT_B5,
    0, 40, 48, 40, 0, 13, 3, 29, 1, 16000000);

  if (!rgbpanel) {
    Serial.println("[ERROR] ❌ RGB panel allocation failed!");
    while (true) delay(1000);
  }

  gfx = new Arduino_RGB_Display(SCREEN_W, SCREEN_H, rgbpanel);
  if (!gfx) {
    Serial.println("[ERROR] ❌ gfx allocation failed!");
    while (true) delay(1000);
  }

  Serial.printf("[DEBUG] Free heap: %d KB | Free PSRAM: %d KB\n",
                ESP.getFreeHeap() / 1024, ESP.getFreePsram() / 1024);

  if (!gfx->begin()) {
    Serial.println("[ERROR] ❌ gfx->begin() failed! Check display wiring or PSRAM.");
    while (true) delay(1000);
  }

  gfx->fillScreen(BLACK);
  gfx->setTextColor(GORE_RED);
  gfx->setTextSize(3);
  gfx->setCursor(150, 180);
  gfx->println("SHOWDUINO STUDIO");
  gfx->setTextSize(2);
  gfx->setCursor(200, 230);
  gfx->println("Gore FX Edition v4.3");
  Serial.println("[1/5] ✓ Display initialized");
  delay(500);

  // ────────────────────────────────────────────────────────────────
  //  Stage 2: LVGL Initialization
  // ────────────────────────────────────────────────────────────────
  gfx->setTextColor(GORE_RED);
  gfx->setCursor(200, 270);
  gfx->println("Initializing LVGL...");
  Serial.println("[BOOT] Initializing LVGL...");

  if (!init_lvgl()) {
    Serial.println("[ERROR] ❌ LVGL init failed – insufficient PSRAM or bad buffers");
    while (true) delay(1000);
  }

  Serial.println("[2/5] ✓ LVGL ready");
  delay(500);

  // ────────────────────────────────────────────────────────────────
  //  Stage 3: Touch Initialization
  // ────────────────────────────────────────────────────────────────
  gfx->setCursor(200, 290);
  gfx->println("Initializing Touch...");
  Serial.println("[BOOT] Initializing GT911 touch...");

  delay(100);  // Ensure I2C bus is stable before touch init
  Wire.begin(TOUCH_SDA, TOUCH_SCL, 400000);

  ts_ptr = new TAMC_GT911(TOUCH_SDA, TOUCH_SCL, TOUCH_INT, TOUCH_RST, SCREEN_W, SCREEN_H);
  if (!ts_ptr) {
    Serial.prin
