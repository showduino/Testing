/*
  ╔════════════════════════════════════════════════════════════════════════════╗
  ║          SHOWDUINO STUDIO – ESP-NOW COMMUNICATIONS EDITION v5.0            ║
  ║   ESP32-S3 UI (JC8048W550C + GT911) → ESP32-S3 Brain (Showduino Core)     ║
  ║                                                                            ║
  ║  • Dedicated live control desk UI built with LVGL                          ║
  ║  • Zero-config ESP-NOW duplex link (binary packets, sub-ms latency)        ║
  ║  • Manual / Monitor modes, timeline scrub, relay grid, MP3 decks, LEDs     ║
  ║  • Dynamic status mirroring from the Brain                                  ║
  ║  • Pairing helper + link quality indicator                                 ║
  ╚════════════════════════════════════════════════════════════════════════════╝
*/

#include <Arduino.h>
#include <Arduino_GFX_Library.h>
#include <lvgl.h>
#include <TAMC_GT911.h>
#include <Wire.h>
#include <ctype.h>
#include <SPI.h>
#include <SD.h>
#include <RTClib.h>
#include <WiFi.h>
#include <esp_now.h>
#include <esp_wifi.h>
#include <cstring>
#include <freertos/FreeRTOS.h>
#include <freertos/semphr.h>

#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"

// ────────────────────────────────────────────────────────────────
//  HARDWARE DEFINITIONS – JC8048W550C + GT911
// ────────────────────────────────────────────────────────────────
#define TFT_BL 2
#define TFT_DE 40
#define TFT_VSYNC 41
#define TFT_HSYNC 39
#define TFT_PCLK 42
#define TFT_R1 45
#define TFT_R2 48
#define TFT_R3 47
#define TFT_R4 21
#define TFT_R5 14
#define TFT_G0 5
#define TFT_G1 6
#define TFT_G2 7
#define TFT_G3 15
#define TFT_G4 16
#define TFT_G5 4
#define TFT_B1 8
#define TFT_B2 3
#define TFT_B3 46
#define TFT_B4 9
#define TFT_B5 1

#define TOUCH_SDA 19
#define TOUCH_SCL 20
#define TOUCH_INT 38
#define TOUCH_RST 10

constexpr uint16_t SCREEN_W = 800;
constexpr uint16_t SCREEN_H = 480;
constexpr uint32_t DRAW_BUF_SIZE = SCREEN_W * 24;  // double buffer lines

constexpr int16_t RAW_X_MIN = 30;
constexpr int16_t RAW_X_MAX = 271;
constexpr int16_t RAW_Y_MIN = 18;
constexpr int16_t RAW_Y_MAX = 450;
constexpr int16_t PAD_LEFT = 10;
constexpr int16_t PAD_RIGHT = 5;
constexpr int16_t PAD_TOP = 8;
constexpr int16_t PAD_BOTTOM = 6;

// ────────────────────────────────────────────────────────────────
//  GORE FX THEME
// ────────────────────────────────────────────────────────────────
constexpr uint32_t GORE_BLACK = 0x000000;
constexpr uint32_t GORE_RED = 0xA30000;
constexpr uint32_t GORE_DARK_RED = 0x550000;
constexpr uint32_t GORE_BRIGHT_RED = 0xFF0000;
constexpr uint32_t GORE_PANEL_BG = 0x111111;
constexpr uint32_t GORE_SLATE = 0x1C1C1C;

#ifndef SD_CS_PIN
#define SD_CS_PIN 12
#endif

static constexpr const char *SHOW_LIBRARY_DIR = "/shows";
static constexpr const char *BUILDER_EXPORT_DIR = "/builder";
static constexpr const char *MP3_SD_MOUNT_CMD = "mp3_scan";
static constexpr uint8_t BOOT_STAGE_TOTAL = 7;

// ────────────────────────────────────────────────────────────────
//  ESP-NOW LINK CONFIG
// ────────────────────────────────────────────────────────────────
constexpr uint8_t SHOWDUINO_ESPNOW_CHANNEL = 6;  // must match Brain
constexpr int SHOWDUINO_MAX_TX_POWER = 78;       // ~20 dBm
constexpr uint32_t LINK_STALE_MS = 1500;
constexpr uint32_t LINK_LOST_MS = 5000;
constexpr uint32_t TIMELINE_MAX_MS = 600000;     // 10 minutes

// ────────────────────────────────────────────────────────────────
//  ESP-NOW PACKET DEFINITIONS
// ────────────────────────────────────────────────────────────────
enum CommandType : uint8_t {
  CMD_NOP = 0,
  CMD_RELAY = 1,
  CMD_CONTROL_MODE = 2,
  CMD_TIMELINE_PREVIEW = 3,
  CMD_TIMELINE_PLAY = 4,
  CMD_MP3_PLAY = 5,
  CMD_MP3_STOP = 6,
  CMD_MP3_VOLUME = 7,
  CMD_LED = 8,
  CMD_STOP_ALL = 9,
  CMD_NEXT_CUE = 10,
  CMD_PREV_CUE = 11,
  CMD_PING = 12,
  CMD_TIMELINE_REWIND = 13,
  CMD_TIMELINE_FWD = 14,
  CMD_TIMELINE_LOOP = 15,
  CMD_SYNC_SD = 16,
  CMD_MP3_SCAN = 17,
  CMD_REQUEST_FILE_LIST = 18
};

enum ControlMode : uint8_t {
  MODE_AUTO = 0,
  MODE_MANUAL = 1
};

struct ShowduinoCommand {
  uint8_t type;
  uint8_t id;
  uint16_t value;
  uint32_t position;
} __attribute__((packed));

struct ShowduinoStatus {
  uint8_t mode;              // ControlMode
  uint8_t relays[8];
  uint8_t mp3Vol[2];
  uint8_t mp3State[2];       // 0 = stop, 1 = play
  uint16_t ledBrightness[4];
  uint32_t timelinePos;      // ms
  uint8_t activeCue;
} __attribute__((packed));

static_assert(sizeof(ShowduinoCommand) == 8, "Unexpected ShowduinoCommand size");
static_assert(sizeof(ShowduinoStatus) == 26, "Unexpected ShowduinoStatus size");

// ────────────────────────────────────────────────────────────────
//  GLOBAL OBJECTS & BUFFERS
// ────────────────────────────────────────────────────────────────
static Arduino_ESP32RGBPanel *rgbpanel = nullptr;
static Arduino_RGB_Display *gfx = nullptr;
static TAMC_GT911 *ts_ptr = nullptr;

static lv_disp_draw_buf_t draw_buf;
static lv_color_t *buf1 = nullptr;
static lv_color_t *buf2 = nullptr;

// UI Screens
static lv_obj_t *screen_main = nullptr;
static lv_obj_t *screen_timeline = nullptr;
static lv_obj_t *screen_fx_designer = nullptr;
static lv_obj_t *screen_live_control = nullptr;
static lv_obj_t *screen_settings = nullptr;
static lv_obj_t *screen_diagnostics = nullptr;
static lv_obj_t *screen_builder = nullptr;
static lv_obj_t *screen_files = nullptr;
static lv_obj_t *crosshair = nullptr;

// Live Control UI elements
static lv_obj_t *live_mode_btn = nullptr;
static lv_obj_t *live_mode_label = nullptr;
static lv_obj_t *live_signal_label = nullptr;
static lv_obj_t *live_peer_label = nullptr;
static lv_obj_t *live_timeline_slider = nullptr;
static lv_obj_t *live_timeline_label = nullptr;
static lv_obj_t *live_cue_label = nullptr;
static lv_obj_t *relayButtons[8] = {nullptr};
static lv_obj_t *mp3VolumeSlider[2] = {nullptr};
static lv_obj_t *mp3StateLabel[2] = {nullptr};
static lv_obj_t *ledSlider[4] = {nullptr};

// Settings UI elements
static lv_obj_t *settings_brightness_slider = nullptr;
static lv_obj_t *settings_brightness_value = nullptr;
static lv_obj_t *settings_autopair_switch = nullptr;
static lv_obj_t *settings_autopair_label = nullptr;
static lv_obj_t *settings_txpower_slider = nullptr;
static lv_obj_t *settings_txpower_value = nullptr;
static lv_obj_t *settings_channel_label = nullptr;
static lv_obj_t *settings_peer_label = nullptr;
static lv_obj_t *settings_last_status_label = nullptr;
static lv_obj_t *settings_ping_label = nullptr;
static lv_obj_t *settings_timeline_loop_btn = nullptr;
static lv_obj_t *settings_time_label = nullptr;
static lv_obj_t *settings_time_input = nullptr;
static lv_obj_t *settings_time_apply_btn = nullptr;

// Diagnostics UI elements
static lv_obj_t *diag_mode_label = nullptr;
static lv_obj_t *diag_relay_label = nullptr;
static lv_obj_t *diag_mp3_label = nullptr;
static lv_obj_t *diag_led_label = nullptr;
static lv_obj_t *diag_timeline_label = nullptr;
static lv_obj_t *diag_last_update_label = nullptr;

// Builder UI elements
static lv_obj_t *builder_library_panel = nullptr;
static lv_obj_t *builder_show_list = nullptr;
static lv_obj_t *builder_timeline_area = nullptr;
static lv_obj_t *builder_name_field = nullptr;
static lv_obj_t *builder_status_label = nullptr;
static lv_obj_t *builder_save_button = nullptr;
static lv_obj_t *toast_container = nullptr;
static lv_obj_t *keyboard = nullptr;
static lv_obj_t *keyboard_target = nullptr;

struct ShowEntry {
  lv_obj_t *widget;
  char name[64];
  lv_coord_t homeX;
  lv_coord_t homeY;
  lv_coord_t dragOffsetX;
  lv_coord_t dragOffsetY;
  bool floating;
};

struct BuilderClip {
  lv_obj_t *widget;
  char showName[64];
  uint32_t startMs;
  uint8_t lane;
};

static constexpr size_t MAX_SHOW_LIBRARY_ENTRIES = 64;
static constexpr size_t MAX_BUILDER_CLIPS = 64;
static ShowEntry builderShowEntries[MAX_SHOW_LIBRARY_ENTRIES];
static size_t builderShowCount = 0;
static BuilderClip builderClips[MAX_BUILDER_CLIPS];
static size_t builderClipCount = 0;

// File browser UI elements
static lv_obj_t *files_path_label = nullptr;
static lv_obj_t *files_list = nullptr;
static lv_obj_t *files_refresh_btn = nullptr;
static char files_current_path[128] = "/";

// FX designer library
static lv_obj_t *fx_library_panel = nullptr;
static lv_obj_t *fx_library_list = nullptr;

struct FileEntry {
  lv_obj_t *button;
  char path[128];
  bool isDir;
};

static FileEntry fileEntries[128];
static size_t fileEntryCount = 0;

// User-data backing arrays (stable memory for LVGL callbacks)
static uint8_t relayIdMap[8] = {0, 1, 2, 3, 4, 5, 6, 7};
static uint8_t mp3DeckMap[2] = {0, 1};
static uint8_t ledLineMap[4] = {0, 1, 2, 3};

enum Mp3Action : uint8_t { MP3_ACT_PLAY = 0, MP3_ACT_STOP = 1 };
struct Mp3ButtonMeta {
  uint8_t deck;
  Mp3Action action;
};
static Mp3ButtonMeta mp3ButtonMeta[4] = {};

// State
static bool systemReady = false;
static bool uiCreated = false;
static int uiStage = 0;
static bool espNowReady = false;
static bool brainPeerKnown = false;
static bool autoPairEnabled = true;
static int currentTxPower = SHOWDUINO_MAX_TX_POWER;
static uint8_t currentChannel = SHOWDUINO_ESPNOW_CHANNEL;
static uint8_t brainPeerMac[6] = {0};
static uint32_t lastStatusMillis = 0;
static volatile esp_now_send_status_t lastSendStatus = ESP_NOW_SEND_FAIL;
static volatile uint32_t lastSendMillis = 0;
static bool timelineLoopEnabled = false;
static RTC_DS3231 rtc;
static bool rtcReady = false;
static DateTime rtcNow;
static uint32_t lastRtcUpdate = 0;

static ShowduinoStatus latestStatus{};
static ShowduinoStatus statusBuffer{};
static volatile bool statusAvailable = false;
static portMUX_TYPE statusMux = portMUX_INITIALIZER_UNLOCKED;

static bool updatingFromStatus = false;
static bool updatingSettingsUi = false;

// Backlight control
constexpr uint8_t BACKLIGHT_PWM_CHANNEL = 0;
constexpr uint32_t BACKLIGHT_PWM_FREQ = 5000;
constexpr uint8_t BACKLIGHT_PWM_RESOLUTION = 12;  // 0..4095
static uint8_t displayBrightness = 255;

// Link diagnostics
static bool pingPending = false;
static uint32_t lastPingSendMillis = 0;
static uint32_t lastPingRoundtrip = 0;

// Storage backend
enum StorageBackend {
  STORAGE_NONE = 0,
  STORAGE_SD
};

static StorageBackend storageBackend = STORAGE_NONE;
static bool storageReady = false;
static bool sdMounted = false;

static constexpr uint8_t BUILDER_LANE_COUNT = 4;
static constexpr lv_coord_t BUILDER_LANE_HEIGHT = 70;
static constexpr lv_coord_t BUILDER_CLIP_WIDTH = 180;
static constexpr lv_coord_t BUILDER_CLIP_HEIGHT = 60;
static uint32_t builderTimelineMs = 600000;
static constexpr uint32_t BUILDER_TIMELINE_MS_MIN = 60000;
static constexpr uint32_t BUILDER_TIMELINE_MS_MAX = 1800000;

static lv_timer_t *toast_timer = nullptr;

// ────────────────────────────────────────────────────────────────
//  FORWARD DECLARATIONS
// ────────────────────────────────────────────────────────────────
void showBootScreen(int stage, const char *message);
bool init_lvgl();
void build_ui_incremental();
void create_main_menu();
void create_timeline_screen();
void create_fx_designer_screen();
void create_live_control_screen();
void create_settings_screen();
void create_diagnostics_screen();
void create_builder_screen();
void update_live_controls(const ShowduinoStatus &status);
void update_link_indicator();
void update_settings_telemetry();
void update_diagnostics_panel(const ShowduinoStatus &status);
void refresh_show_library();
void builder_show_item_event_cb(lv_event_t *e);
void builder_clip_event_cb(lv_event_t *e);
void builder_save_event_cb(lv_event_t *e);
void builder_clear_workspace();
void builder_reset_show_item(ShowEntry *entry);
void builder_add_clip(const char *name, uint32_t startMs, uint8_t lane);
void builder_clear_event_cb(lv_event_t *e);
void show_toast(const char *message, uint32_t duration_ms = 2000);
void hide_toast();
void attach_keyboard(lv_obj_t *target);
void detach_keyboard();
void builder_timeline_slider_event_cb(lv_event_t *e);
bool init_rtc();
void update_clock_display();
bool set_rtc_from_string(const char *input);
void settings_timeline_control_event_cb(lv_event_t *e);
void settings_loop_toggle_event_cb(lv_event_t *e);
void settings_sync_event_cb(lv_event_t *e);
void settings_time_apply_event_cb(lv_event_t *e);
void create_file_browser_screen();
void populate_file_browser(const char *path);
void files_item_event_cb(lv_event_t *e);
void files_back_event_cb(lv_event_t *e);
void files_refresh_event_cb(lv_event_t *e);
void create_fx_library_panel(lv_obj_t *parent);
void refresh_fx_library();
void fx_library_item_event_cb(lv_event_t *e);
void send_timeline_command(CommandType type, uint32_t position = 0, uint16_t value = 0);
bool send_showduino_command(const ShowduinoCommand &cmd);
bool init_esp_now();
void forget_brain_peer();
void handle_status_queue();
void refresh_timeline_readout(uint32_t position);
void update_mp3_state_label(uint8_t deck, uint8_t state);
void apply_display_brightness(uint8_t level);
void init_backlight_pwm();
bool init_storage();
bool ensure_show_library_dir();
bool load_show_library_from_storage();
bool save_builder_to_storage(const char *name);

// LVGL callbacks
void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p);
void my_touchpad_read(lv_indev_drv_t *indev_driver, lv_indev_data_t *data);
void mode_toggle_event_cb(lv_event_t *e);
void timeline_event_cb(lv_event_t *e);
void relay_event_cb(lv_event_t *e);
void mp3_volume_event_cb(lv_event_t *e);
void mp3_transport_event_cb(lv_event_t *e);
void led_slider_event_cb(lv_event_t *e);
void toolbar_event_cb(lv_event_t *e);
void pair_button_event_cb(lv_event_t *e);
void settings_brightness_event_cb(lv_event_t *e);
void settings_autopair_event_cb(lv_event_t *e);
void settings_txpower_event_cb(lv_event_t *e);
void settings_ping_event_cb(lv_event_t *e);
void settings_back_event_cb(lv_event_t *e);
void diagnostics_back_event_cb(lv_event_t *e);

// ESP-NOW callbacks
void on_espnow_recv(const uint8_t *mac, const uint8_t *incomingData, int len);
void on_espnow_sent(const uint8_t *mac, esp_now_send_status_t status);
bool ensure_peer_registered(const uint8_t *mac);

// Utility
void format_timecode(uint32_t ms, char *buffer, size_t len);

// ────────────────────────────────────────────────────────────────
//  DISPLAY FLUSH
// ────────────────────────────────────────────────────────────────
void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) {
  if (!gfx) {
    lv_disp_flush_ready(disp);
    return;
  }

  uint32_t w = area->x2 - area->x1 + 1;
  uint32_t h = area->y2 - area->y1 + 1;
  gfx->draw16bitRGBBitmap(area->x1, area->y1, (uint16_t *)&color_p->full, w, h);
  lv_disp_flush_ready(disp);
}

// ────────────────────────────────────────────────────────────────
//  TOUCH DRIVER
// ────────────────────────────────────────────────────────────────
void my_touchpad_read(lv_indev_drv_t *indev_driver, lv_indev_data_t *data) {
  if (!ts_ptr) {
    data->state = LV_INDEV_STATE_REL;
    return;
  }

  ts_ptr->read();

  if (ts_ptr->isTouched) {
    int16_t rawX = ts_ptr->points[0].x;
    int16_t rawY = ts_ptr->points[0].y;

    int16_t x = map(rawY, RAW_Y_MAX, RAW_Y_MIN, PAD_LEFT, SCREEN_W - 1 - PAD_RIGHT);
    int16_t y = map(rawX, RAW_X_MIN, RAW_X_MAX, PAD_TOP, SCREEN_H - 1 - PAD_BOTTOM);

    data->point.x = constrain(x, 0, static_cast<int16_t>(SCREEN_W - 1));
    data->point.y = constrain(y, 0, static_cast<int16_t>(SCREEN_H - 1));
    data->state = LV_INDEV_STATE_PR;

    if (crosshair) {
      lv_obj_clear_flag(crosshair, LV_OBJ_FLAG_HIDDEN);
      lv_obj_set_pos(crosshair, data->point.x - 10, data->point.y - 10);
    }
  } else {
    data->state = LV_INDEV_STATE_REL;
    if (crosshair) {
      lv_obj_add_flag(crosshair, LV_OBJ_FLAG_HIDDEN);
    }
  }
}

bool init_storage() {
  if (storageBackend == STORAGE_SD && sdMounted) {
    return true;
  }

#ifdef SD_SCK_PIN
  SPI.begin(SD_SCK_PIN, SD_MISO_PIN, SD_MOSI_PIN, SD_CS_PIN);
#else
  SPI.begin();
#endif

  if (SD.begin(SD_CS_PIN)) {
    storageBackend = STORAGE_SD;
    sdMounted = true;
    storageReady = true;
    Serial.println("[STORAGE] SD card mounted as primary storage");
      ensure_show_library_dir();
      const char *registryPath = "/builder/registry.txt";
      if (!SD.exists(registryPath)) {
        File regFile = SD.open(registryPath, FILE_WRITE);
        if (regFile) {
          regFile.println("# Show Registry");
          regFile.close();
        }
      }
    return true;
  }

  storageBackend = STORAGE_NONE;
  sdMounted = false;
  storageReady = false;
  Serial.println("[STORAGE] ⚠️ SD card not detected – using transient memory only");
  return false;
}

bool ensure_show_library_dir() {
  if (storageBackend != STORAGE_SD || !sdMounted) return false;
  if (!SD.exists(SHOW_LIBRARY_DIR)) {
    SD.mkdir(SHOW_LIBRARY_DIR);
  }
  if (!SD.exists(BUILDER_EXPORT_DIR)) {
    SD.mkdir(BUILDER_EXPORT_DIR);
  }
  return true;
}

static void sanitise_show_name(const char *source, char *dest, size_t destLen) {
  size_t di = 0;
  for (size_t i = 0; source[i] != '\0' && di < destLen - 1; ++i) {
    char c = source[i];
    if (c == '.' || c == '/' || c == '\\') break;
    if (isalnum(static_cast<unsigned char>(c)) || c == '_' || c == '-' || c == ' ') {
      dest[di++] = c;
    } else {
      dest[di++] = '_';
    }
  }
  dest[di] = '\0';
}

bool load_show_library_from_storage() {
  builderShowCount = 0;

  if (init_storage() && storageBackend == STORAGE_SD && sdMounted) {
    ensure_show_library_dir();
    File dir = SD.open(SHOW_LIBRARY_DIR);
    if (dir) {
      while (true) {
        File entry = dir.openNextFile();
        if (!entry) break;
        if (!entry.isDirectory() && builderShowCount < MAX_SHOW_LIBRARY_ENTRIES) {
          const char *rawName = entry.name();
          const char *leaf = strrchr(rawName, '/');
          leaf = leaf ? leaf + 1 : rawName;
          char cleaned[64]{0};
          sanitise_show_name(leaf, cleaned, sizeof(cleaned));
          if (cleaned[0] != '\0') {
            ShowEntry &slot = builderShowEntries[builderShowCount++];
            memset(&slot, 0, sizeof(slot));
            strncpy(slot.name, cleaned, sizeof(slot.name) - 1);
          }
        }
        entry.close();
      }
      dir.close();
    }
  }

  if (builderShowCount == 0) {
    ShowEntry &slot = builderShowEntries[builderShowCount++];
    memset(&slot, 0, sizeof(slot));
    strncpy(slot.name, "Demo FX Cue", sizeof(slot.name) - 1);
  }

  return builderShowCount > 0;
}

bool save_builder_to_storage(const char *name) {
  if (!name || !*name) return false;
  if (!init_storage() || storageBackend != STORAGE_SD || !sdMounted) return false;
  ensure_show_library_dir();

  char safeName[64];
  sanitise_show_name(name, safeName, sizeof(safeName));
  if (safeName[0] == '\0') {
    strncpy(safeName, "untitled_show", sizeof(safeName) - 1);
  }

  String path = String(BUILDER_EXPORT_DIR) + "/" + safeName + ".show";
  File file = SD.open(path.c_str(), FILE_WRITE);
  if (!file) {
    Serial.printf("[STORAGE] ❌ Failed to open %s for writing\n", path.c_str());
    return false;
  }

  file.print("{\"clips\":[");
  for (size_t i = 0; i < builderClipCount; ++i) {
    const BuilderClip &clip = builderClips[i];
    file.printf("{\"show\":\"%s\",\"lane\":%u,\"start\":%lu,\"length\":%lu}",
                clip.showName,
                static_cast<unsigned>(clip.lane),
                static_cast<unsigned long>(clip.startMs),
                static_cast<unsigned long>(builderTimelineMs / 16));
    if (i + 1 < builderClipCount) file.print(",");
  }
  file.print("]}");
  file.close();
  String registryPath = String(BUILDER_EXPORT_DIR) + "/registry.txt";
  File registry = SD.open(registryPath.c_str(), FILE_APPEND);
  if (registry) {
    registry.printf("%s.show\n", safeName);
    registry.close();
  }
  Serial.printf("[STORAGE] ✓ Builder arrangement saved to %s\n", path.c_str());
  return true;
}

// ────────────────────────────────────────────────────────────────
//  UI FEEDBACK HELPERS
// ────────────────────────────────────────────────────────────────
static void toast_timer_cb(lv_timer_t *timer) {
  (void)timer;
  hide_toast();
}

void hide_toast() {
  if (!toast_container) return;
  lv_obj_add_flag(toast_container, LV_OBJ_FLAG_HIDDEN);
  lv_obj_t *label = lv_obj_get_child(toast_container, 0);
  if (label) lv_label_set_text(label, "");
  if (toast_timer) {
    lv_timer_del(toast_timer);
    toast_timer = nullptr;
  }
}

void show_toast(const char *message, uint32_t duration_ms) {
  if (!toast_container) return;
  lv_obj_clear_flag(toast_container, LV_OBJ_FLAG_HIDDEN);
  lv_obj_t *label = lv_obj_get_child(toast_container, 0);
  if (label) {
    lv_label_set_text(label, message ? message : "");
    lv_obj_center(label);
  }
  if (toast_timer) {
    lv_timer_set_period(toast_timer, duration_ms);
    lv_timer_reset(toast_timer);
  } else {
    toast_timer = lv_timer_create(toast_timer_cb, duration_ms, nullptr);
  }
}

void attach_keyboard(lv_obj_t *target) {
  if (!target) return;
  if (!keyboard) {
    keyboard = lv_keyboard_create(lv_scr_act());
    lv_obj_set_size(keyboard, SCREEN_W, SCREEN_H / 3);
    lv_obj_align(keyboard, LV_ALIGN_BOTTOM_MID, 0, 0);
    lv_keyboard_set_mode(keyboard, LV_KEYBOARD_MODE_TEXT_LOWER);
    lv_obj_add_flag(keyboard, LV_OBJ_FLAG_HIDDEN);
  }
  keyboard_target = target;
  lv_keyboard_set_textarea(keyboard, target);
  lv_obj_clear_flag(keyboard, LV_OBJ_FLAG_HIDDEN);
}

void detach_keyboard() {
  if (!keyboard) return;
  lv_keyboard_set_textarea(keyboard, nullptr);
  lv_obj_add_flag(keyboard, LV_OBJ_FLAG_HIDDEN);
  keyboard_target = nullptr;
}

bool init_rtc() {
  rtcReady = rtc.begin();
  if (!rtcReady) {
    Serial.println("[RTC] ⚠️ DS3231 not detected");
    return false;
  }
  if (rtc.lostPower()) {
    Serial.println("[RTC] ⚠️ Lost power, setting compile time by default");
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
  }
  rtcNow = rtc.now();
  update_clock_display();
  Serial.printf("[RTC] ✓ Initialised: %04d-%02d-%02d %02d:%02d:%02d\n",
                rtcNow.year(), rtcNow.month(), rtcNow.day(),
                rtcNow.hour(), rtcNow.minute(), rtcNow.second());
  return true;
}

void update_clock_display() {
  if (!settings_time_label) return;
  if (!rtcReady) {
    lv_label_set_text(settings_time_label, "RTC: unavailable");
    return;
  }
  rtcNow = rtc.now();
  char buf[64];
  snprintf(buf, sizeof(buf), "RTC: %04d-%02d-%02d %02d:%02d:%02d",
           rtcNow.year(), rtcNow.month(), rtcNow.day(),
           rtcNow.hour(), rtcNow.minute(), rtcNow.second());
  lv_label_set_text(settings_time_label, buf);
}

bool set_rtc_from_string(const char *input) {
  if (!input || !rtcReady) return false;
  int year, month, day, hour, minute, second;
  if (sscanf(input, "%d-%d-%d %d:%d:%d",
             &year, &month, &day, &hour, &minute, &second) != 6) {
    return false;
  }
  if (year < 2000 || year > 2099) return false;
  DateTime dt(year, month, day, hour, minute, second);
  rtc.adjust(dt);
  rtcNow = dt;
  update_clock_display();
  return true;
}

// ────────────────────────────────────────────────────────────────
//  LVGL INIT
// ────────────────────────────────────────────────────────────────
bool init_lvgl() {
  lv_init();

  buf1 = (lv_color_t *)ps_malloc(sizeof(lv_color_t) * DRAW_BUF_SIZE);
  if (!buf1) {
    Serial.println("[LVGL] ❌ Failed to allocate buffer 1 (PSRAM)");
    return false;
  }

  buf2 = (lv_color_t *)ps_malloc(sizeof(lv_color_t) * DRAW_BUF_SIZE);
  if (!buf2) {
    Serial.println("[LVGL] ❌ Failed to allocate buffer 2 (PSRAM)");
    free(buf1);
    buf1 = nullptr;
    return false;
  }

  lv_disp_draw_buf_init(&draw_buf, buf1, buf2, DRAW_BUF_SIZE);

  static lv_disp_drv_t disp_drv;
  lv_disp_drv_init(&disp_drv);
  disp_drv.hor_res = SCREEN_W;
  disp_drv.ver_res = SCREEN_H;
  disp_drv.flush_cb = my_disp_flush;
  disp_drv.draw_buf = &draw_buf;
  lv_disp_drv_register(&disp_drv);

  static lv_indev_drv_t indev_drv;
  lv_indev_drv_init(&indev_drv);
  indev_drv.type = LV_INDEV_TYPE_POINTER;
  indev_drv.read_cb = my_touchpad_read;
  lv_indev_drv_register(&indev_drv);

  return true;
}

// ────────────────────────────────────────────────────────────────
//  BOOT SCREEN HELPERS
// ────────────────────────────────────────────────────────────────
void showBootScreen(int stage, const char *message) {
  if (!gfx) return;

  gfx->fillScreen(BLACK);
  gfx->setTextColor(GORE_RED);
  gfx->setTextSize(3);
  gfx->setCursor(150, 170);
  gfx->println("SHOWDUINO STUDIO");

  gfx->setTextSize(2);
  gfx->setCursor(180, 215);
  gfx->println("ESP-NOW Communications Edition v5.0");

  gfx->setTextSize(1);
  gfx->setCursor(280, 260);
  gfx->printf("Stage %d/%d", stage, BOOT_STAGE_TOTAL);

  gfx->setCursor(200, 285);
  gfx->println(message);
}

// ────────────────────────────────────────────────────────────────
//  MAIN MENU
// ────────────────────────────────────────────────────────────────
void create_main_menu() {
  Serial.println("[UI] Creating main menu...");

  screen_main = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(screen_main, lv_color_hex(GORE_BLACK), LV_PART_MAIN);

  lv_obj_t *header = lv_label_create(screen_main);
  lv_label_set_text(header, "SHOWDUINO STUDIO");
  lv_obj_set_style_text_color(header, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_text_font(header, &lv_font_montserrat_30, LV_PART_MAIN);
  lv_obj_align(header, LV_ALIGN_TOP_MID, 0, 24);

  lv_obj_t *subtitle = lv_label_create(screen_main);
  lv_label_set_text(subtitle, "Gore FX – ESP-NOW Link Ready");
  lv_obj_set_style_text_color(subtitle, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);
  lv_obj_set_style_text_font(subtitle, &lv_font_montserrat_18, LV_PART_MAIN);
  lv_obj_align(subtitle, LV_ALIGN_TOP_MID, 0, 68);

  lv_obj_t *menu_panel = lv_obj_create(screen_main);
  lv_obj_set_size(menu_panel, 360, 360);
  lv_obj_align(menu_panel, LV_ALIGN_CENTER, 0, 30);
  lv_obj_set_style_bg_color(menu_panel, lv_color_hex(GORE_PANEL_BG), LV_PART_MAIN);
  lv_obj_set_style_border_color(menu_panel, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(menu_panel, 2, LV_PART_MAIN);
  lv_obj_set_style_radius(menu_panel, 16, LV_PART_MAIN);
  lv_obj_set_style_pad_all(menu_panel, 12, LV_PART_MAIN);
  lv_obj_set_flex_flow(menu_panel, LV_FLEX_FLOW_COLUMN);
  lv_obj_set_flex_align(menu_panel, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_SPACE_AROUND);

  auto make_button = [](lv_obj_t *parent, const char *text) {
    lv_obj_t *btn = lv_btn_create(parent);
    lv_obj_set_size(btn, LV_PCT(100), 70);
    lv_obj_set_style_bg_color(btn, lv_color_hex(GORE_RED), LV_PART_MAIN);
    lv_obj_set_style_bg_color(btn, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN | LV_STATE_PRESSED);
    lv_obj_set_style_border_width(btn, 0, LV_PART_MAIN);
    lv_obj_set_style_radius(btn, 10, LV_PART_MAIN);

    lv_obj_t *label = lv_label_create(btn);
    lv_label_set_text(label, text);
    lv_obj_set_style_text_font(label, &lv_font_montserrat_20, LV_PART_MAIN);
    lv_obj_center(label);
    return btn;
  };

  lv_obj_t *btn_live = make_button(menu_panel, LV_SYMBOL_WIFI " LIVE CONTROL");
  lv_obj_add_event_cb(btn_live, [](lv_event_t *e) {
    if (screen_live_control) {
      lv_scr_load_anim(screen_live_control, LV_SCR_LOAD_ANIM_MOVE_LEFT, 250, 0, false);
    }
  }, LV_EVENT_CLICKED, NULL);

  lv_obj_t *btn_timeline = make_button(menu_panel, LV_SYMBOL_PLAY " TIMELINE EDITOR");
  lv_obj_add_event_cb(btn_timeline, [](lv_event_t *e) {
    if (screen_timeline) {
      lv_scr_load_anim(screen_timeline, LV_SCR_LOAD_ANIM_MOVE_LEFT, 250, 0, false);
    }
  }, LV_EVENT_CLICKED, NULL);

  lv_obj_t *btn_fx = make_button(menu_panel, LV_SYMBOL_IMAGE " FX DESIGNER");
  lv_obj_add_event_cb(btn_fx, [](lv_event_t *e) {
    if (screen_fx_designer) {
      lv_scr_load_anim(screen_fx_designer, LV_SCR_LOAD_ANIM_MOVE_LEFT, 250, 0, false);
    }
  }, LV_EVENT_CLICKED, NULL);

  lv_obj_t *btn_builder = make_button(menu_panel, LV_SYMBOL_AUDIO " SHOW BUILDER");
  lv_obj_add_event_cb(btn_builder, [](lv_event_t *e) {
    if (screen_builder) {
      lv_scr_load_anim(screen_builder, LV_SCR_LOAD_ANIM_MOVE_LEFT, 250, 0, false);
    } else {
      Serial.println("[UI] Builder screen not initialised yet.");
    }
  }, LV_EVENT_CLICKED, NULL);

  lv_obj_t *btn_settings = make_button(menu_panel, LV_SYMBOL_SETTINGS " SETTINGS");
  lv_obj_add_event_cb(btn_settings, [](lv_event_t *e) {
    if (screen_settings) {
      lv_scr_load_anim(screen_settings, LV_SCR_LOAD_ANIM_MOVE_LEFT, 250, 0, false);
    }
  }, LV_EVENT_CLICKED, NULL);

  lv_obj_t *btn_diag = make_button(menu_panel, LV_SYMBOL_LIST " DIAGNOSTICS");
  lv_obj_add_event_cb(btn_diag, [](lv_event_t *e) {
    if (screen_diagnostics) {
      lv_scr_load_anim(screen_diagnostics, LV_SCR_LOAD_ANIM_MOVE_LEFT, 250, 0, false);
    }
  }, LV_EVENT_CLICKED, NULL);

  lv_obj_t *footer = lv_label_create(screen_main);
  lv_label_set_text(footer, "ESP-NOW Link: tap LIVE CONTROL to pair");
  lv_obj_set_style_text_color(footer, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);
  lv_obj_align(footer, LV_ALIGN_BOTTOM_MID, 0, -12);

  // Crosshair for touch debug
  crosshair = lv_obj_create(screen_main);
  lv_obj_set_size(crosshair, 24, 24);
  lv_obj_set_style_bg_color(crosshair, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_radius(crosshair, 12, LV_PART_MAIN);
  lv_obj_add_flag(crosshair, LV_OBJ_FLAG_FLOATING | LV_OBJ_FLAG_HIDDEN);

  lv_scr_load(screen_main);
  Serial.println("[UI] Main menu complete");
}

// ────────────────────────────────────────────────────────────────
//  TIMELINE SCREEN (placeholder)
// ────────────────────────────────────────────────────────────────
void create_timeline_screen() {
  Serial.println("[UI] Creating timeline editor...");

  screen_timeline = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(screen_timeline, lv_color_hex(GORE_BLACK), LV_PART_MAIN);

  lv_obj_t *header = lv_label_create(screen_timeline);
  lv_label_set_text(header, LV_SYMBOL_PLAY " TIMELINE EDITOR");
  lv_obj_set_style_text_color(header, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_text_font(header, &lv_font_montserrat_24, LV_PART_MAIN);
  lv_obj_align(header, LV_ALIGN_TOP_LEFT, 20, 20);

  lv_obj_t *btn_back = lv_btn_create(screen_timeline);
  lv_obj_set_size(btn_back, 110, 48);
  lv_obj_align(btn_back, LV_ALIGN_TOP_RIGHT, -20, 18);
  lv_obj_set_style_bg_color(btn_back, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(btn_back, 0, LV_PART_MAIN);

  lv_obj_t *label_back = lv_label_create(btn_back);
  lv_label_set_text(label_back, LV_SYMBOL_LEFT " BACK");
  lv_obj_center(label_back);

  lv_obj_add_event_cb(btn_back, [](lv_event_t *e) {
    if (screen_main) {
      lv_scr_load_anim(screen_main, LV_SCR_LOAD_ANIM_MOVE_RIGHT, 300, 0, false);
    }
  }, LV_EVENT_CLICKED, NULL);

  lv_obj_t *timeline_area = lv_obj_create(screen_timeline);
  lv_obj_set_size(timeline_area, 760, 360);
  lv_obj_align(timeline_area, LV_ALIGN_CENTER, 0, 20);
  lv_obj_set_style_bg_color(timeline_area, lv_color_hex(GORE_PANEL_BG), LV_PART_MAIN);
  lv_obj_set_style_border_color(timeline_area, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(timeline_area, 2, LV_PART_MAIN);

  lv_obj_t *placeholder = lv_label_create(timeline_area);
  lv_label_set_text(placeholder,
                    "TIMELINE SEQUENCER\n\n"
                    "• Drag to build cues\n"
                    "• Assign FX + hardware actions\n"
                    "• Sync to MP3 beat grid\n"
                    "• Tap cue to live preview\n\n"
                    "ESP-NOW link keeps Brain locked to timeline.");
  lv_obj_set_style_text_color(placeholder, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);
  lv_obj_set_style_text_align(placeholder, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN);
  lv_obj_center(placeholder);

  Serial.println("[UI] Timeline editor ready");
}

// ────────────────────────────────────────────────────────────────
//  FX DESIGNER SCREEN (placeholder)
// ────────────────────────────────────────────────────────────────
void create_fx_designer_screen() {
  Serial.println("[UI] Creating FX designer...");

  screen_fx_designer = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(screen_fx_designer, lv_color_hex(GORE_BLACK), LV_PART_MAIN);

  lv_obj_t *header = lv_label_create(screen_fx_designer);
  lv_label_set_text(header, LV_SYMBOL_IMAGE " FX DESIGNER");
  lv_obj_set_style_text_color(header, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_text_font(header, &lv_font_montserrat_24, LV_PART_MAIN);
  lv_obj_align(header, LV_ALIGN_TOP_LEFT, 20, 20);

  lv_obj_t *btn_back = lv_btn_create(screen_fx_designer);
  lv_obj_set_size(btn_back, 110, 48);
  lv_obj_align(btn_back, LV_ALIGN_TOP_RIGHT, -20, 18);
  lv_obj_set_style_bg_color(btn_back, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(btn_back, 0, LV_PART_MAIN);

  lv_obj_t *label_back = lv_label_create(btn_back);
  lv_label_set_text(label_back, LV_SYMBOL_LEFT " BACK");
  lv_obj_center(label_back);

  lv_obj_add_event_cb(btn_back, [](lv_event_t *e) {
    if (screen_main) {
      lv_scr_load_anim(screen_main, LV_SCR_LOAD_ANIM_MOVE_RIGHT, 300, 0, false);
    }
  }, LV_EVENT_CLICKED, NULL);

  lv_obj_t *preview_area = lv_obj_create(screen_fx_designer);
  lv_obj_set_size(preview_area, 760, 360);
  lv_obj_align(preview_area, LV_ALIGN_CENTER, 0, 20);
  lv_obj_set_style_bg_color(preview_area, lv_color_hex(GORE_PANEL_BG), LV_PART_MAIN);
  lv_obj_set_style_border_color(preview_area, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(preview_area, 2, LV_PART_MAIN);

  lv_obj_t *placeholder = lv_label_create(preview_area);
  lv_label_set_text(placeholder,
                    "FX DESIGNER\n\n"
                    "• Build gradients + chases\n"
                    "• Assign to LED lines\n"
                    "• Preview via ESP-NOW\n"
                    "• Store in cue library");
  lv_obj_set_style_text_color(placeholder, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);
  lv_obj_set_style_text_align(placeholder, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN);
  lv_obj_center(placeholder);

  Serial.println("[UI] FX designer ready");
}

// ────────────────────────────────────────────────────────────────
//  LIVE CONTROL SCREEN
// ────────────────────────────────────────────────────────────────
void create_live_control_screen() {
  Serial.println("[UI] Building LIVE CONTROL desk...");

  screen_live_control = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(screen_live_control, lv_color_hex(GORE_BLACK), LV_PART_MAIN);
  lv_obj_set_style_pad_hor(screen_live_control, 16, LV_PART_MAIN);
  lv_obj_set_style_pad_ver(screen_live_control, 12, LV_PART_MAIN);
  lv_obj_set_scrollbar_mode(screen_live_control, LV_SCROLLBAR_MODE_OFF);

  // Top bar
  lv_obj_t *top_bar = lv_obj_create(screen_live_control);
  lv_obj_set_size(top_bar, SCREEN_W - 32, 80);
  lv_obj_align(top_bar, LV_ALIGN_TOP_MID, 0, 0);
  lv_obj_set_style_bg_color(top_bar, lv_color_hex(GORE_SLATE), LV_PART_MAIN);
  lv_obj_set_style_border_width(top_bar, 0, LV_PART_MAIN);
  lv_obj_set_style_pad_all(top_bar, 12, LV_PART_MAIN);
  lv_obj_set_flex_flow(top_bar, LV_FLEX_FLOW_ROW);
  lv_obj_set_flex_align(top_bar, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
  lv_obj_set_style_radius(top_bar, 12, LV_PART_MAIN);

  lv_obj_t *title = lv_label_create(top_bar);
  lv_label_set_text(title, "LIVE CONTROL");
  lv_obj_set_style_text_font(title, &lv_font_montserrat_22, LV_PART_MAIN);
  lv_obj_set_style_text_color(title, lv_color_hex(GORE_BRIGHT_RED), LV_PART_MAIN);

  live_mode_btn = lv_btn_create(top_bar);
  lv_obj_set_size(live_mode_btn, 150, 50);
  lv_obj_set_style_bg_color(live_mode_btn, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);
  lv_obj_set_style_bg_color(live_mode_btn, lv_color_hex(GORE_RED), LV_PART_MAIN | LV_STATE_CHECKED);
  lv_obj_set_style_border_width(live_mode_btn, 0, LV_PART_MAIN);
  lv_obj_set_style_radius(live_mode_btn, 8, LV_PART_MAIN);
  lv_obj_add_flag(live_mode_btn, LV_OBJ_FLAG_CHECKABLE);
  lv_obj_add_event_cb(live_mode_btn, mode_toggle_event_cb, LV_EVENT_VALUE_CHANGED, nullptr);

  live_mode_label = lv_label_create(live_mode_btn);
  lv_label_set_text(live_mode_label, "MONITOR");
  lv_obj_set_style_text_font(live_mode_label, &lv_font_montserrat_16, LV_PART_MAIN);
  lv_obj_center(live_mode_label);

  lv_obj_t *pair_btn = lv_btn_create(top_bar);
  lv_obj_set_size(pair_btn, 110, 50);
  lv_obj_set_style_bg_color(pair_btn, lv_color_hex(GORE_PANEL_BG), LV_PART_MAIN);
  lv_obj_set_style_border_color(pair_btn, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(pair_btn, 2, LV_PART_MAIN);
  lv_obj_set_style_radius(pair_btn, 8, LV_PART_MAIN);
  lv_obj_add_event_cb(pair_btn, pair_button_event_cb, LV_EVENT_CLICKED, nullptr);

  lv_obj_t *pair_label = lv_label_create(pair_btn);
  lv_label_set_text(pair_label, LV_SYMBOL_REFRESH " PAIR");
  lv_obj_set_style_text_font(pair_label, &lv_font_montserrat_16, LV_PART_MAIN);
  lv_obj_center(pair_label);

  live_signal_label = lv_label_create(top_bar);
  lv_label_set_text(live_signal_label, LV_SYMBOL_WIFI " NO LINK");
  lv_obj_set_style_text_font(live_signal_label, &lv_font_montserrat_18, LV_PART_MAIN);
  lv_obj_set_style_text_color(live_signal_label, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);
  lv_obj_set_style_pad_left(live_signal_label, 16, LV_PART_MAIN);

  live_peer_label = lv_label_create(top_bar);
  lv_label_set_text(live_peer_label, "Waiting for Brain...");
  lv_obj_set_style_text_font(live_peer_label, &lv_font_montserrat_16, LV_PART_MAIN);
  lv_obj_set_style_text_color(live_peer_label, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);
  lv_obj_set_style_pad_left(live_peer_label, 18, LV_PART_MAIN);

  // Timeline panel
  lv_obj_t *timeline_panel = lv_obj_create(screen_live_control);
  lv_obj_align(timeline_panel, LV_ALIGN_TOP_LEFT, 0, 96);
  lv_obj_set_size(timeline_panel, SCREEN_W - 32, 100);
  lv_obj_set_style_bg_color(timeline_panel, lv_color_hex(GORE_PANEL_BG), LV_PART_MAIN);
  lv_obj_set_style_border_color(timeline_panel, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(timeline_panel, 2, LV_PART_MAIN);
  lv_obj_set_style_radius(timeline_panel, 12, LV_PART_MAIN);
  lv_obj_set_style_pad_all(timeline_panel, 12, LV_PART_MAIN);

  live_timeline_slider = lv_slider_create(timeline_panel);
  lv_obj_set_size(live_timeline_slider, SCREEN_W - 56, 30);
  lv_slider_set_range(live_timeline_slider, 0, TIMELINE_MAX_MS);
  lv_obj_align(live_timeline_slider, LV_ALIGN_TOP_MID, 0, 4);
  lv_obj_add_event_cb(live_timeline_slider, timeline_event_cb, LV_EVENT_VALUE_CHANGED, nullptr);
  lv_obj_add_event_cb(live_timeline_slider, timeline_event_cb, LV_EVENT_RELEASED, nullptr);

  live_timeline_label = lv_label_create(timeline_panel);
  lv_obj_align(live_timeline_label, LV_ALIGN_BOTTOM_LEFT, 4, -4);
  lv_label_set_text(live_timeline_label, "00:00.0");
  lv_obj_set_style_text_font(live_timeline_label, &lv_font_montserrat_20, LV_PART_MAIN);

  live_cue_label = lv_label_create(timeline_panel);
  lv_obj_align(live_cue_label, LV_ALIGN_BOTTOM_RIGHT, -4, -4);
  lv_label_set_text(live_cue_label, "Cue: --");
  lv_obj_set_style_text_font(live_cue_label, &lv_font_montserrat_20, LV_PART_MAIN);

  // Relay grid
  lv_obj_t *relay_panel = lv_obj_create(screen_live_control);
  lv_obj_set_size(relay_panel, SCREEN_W - 32, 150);
  lv_obj_align(relay_panel, LV_ALIGN_TOP_LEFT, 0, 210);
  lv_obj_set_style_bg_color(relay_panel, lv_color_hex(GORE_PANEL_BG), LV_PART_MAIN);
  lv_obj_set_style_border_color(relay_panel, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(relay_panel, 2, LV_PART_MAIN);
  lv_obj_set_style_radius(relay_panel, 12, LV_PART_MAIN);
  lv_obj_set_style_pad_all(relay_panel, 10, LV_PART_MAIN);
  lv_obj_set_flex_flow(relay_panel, LV_FLEX_FLOW_ROW_WRAP);
  lv_obj_set_flex_align(relay_panel, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);

  for (int i = 0; i < 8; ++i) {
    lv_obj_t *btn = lv_btn_create(relay_panel);
    relayButtons[i] = btn;
    lv_obj_set_size(btn, 160, 60);
    lv_obj_set_style_bg_color(btn, lv_color_hex(GORE_SLATE), LV_PART_MAIN);
    lv_obj_set_style_bg_color(btn, lv_color_hex(GORE_RED), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_border_color(btn, lv_color_hex(GORE_RED), LV_PART_MAIN);
    lv_obj_set_style_border_color(btn, lv_color_hex(GORE_BRIGHT_RED), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_border_width(btn, 2, LV_PART_MAIN);
    lv_obj_set_style_radius(btn, 10, LV_PART_MAIN);
    lv_obj_add_flag(btn, LV_OBJ_FLAG_CHECKABLE);

    char labelTxt[32];
    snprintf(labelTxt, sizeof(labelTxt), "Relay %d", i + 1);
    lv_obj_t *label = lv_label_create(btn);
    lv_label_set_text(label, labelTxt);
    lv_obj_set_style_text_font(label, &lv_font_montserrat_18, LV_PART_MAIN);
    lv_obj_center(label);

    lv_obj_add_event_cb(btn, relay_event_cb, LV_EVENT_VALUE_CHANGED, &relayIdMap[i]);
  }

  // MP3 decks + LED controls container
  lv_obj_t *lower_panel = lv_obj_create(screen_live_control);
  lv_obj_set_size(lower_panel, SCREEN_W - 32, 180);
  lv_obj_align(lower_panel, LV_ALIGN_BOTTOM_MID, 0, -90);
  lv_obj_set_style_bg_color(lower_panel, lv_color_hex(GORE_PANEL_BG), LV_PART_MAIN);
  lv_obj_set_style_border_color(lower_panel, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(lower_panel, 2, LV_PART_MAIN);
  lv_obj_set_style_radius(lower_panel, 12, LV_PART_MAIN);
  lv_obj_set_style_pad_all(lower_panel, 12, LV_PART_MAIN);
  lv_obj_set_flex_flow(lower_panel, LV_FLEX_FLOW_ROW);
  lv_obj_set_flex_align(lower_panel, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER);

  auto build_mp3_deck = [&](uint8_t deckIndex, const char *titleText) {
    lv_obj_t *deck = lv_obj_create(lower_panel);
    lv_obj_set_size(deck, 200, 150);
    lv_obj_set_style_bg_color(deck, lv_color_hex(GORE_SLATE), LV_PART_MAIN);
    lv_obj_set_style_border_width(deck, 0, LV_PART_MAIN);
    lv_obj_set_style_radius(deck, 10, LV_PART_MAIN);
    lv_obj_set_style_pad_all(deck, 10, LV_PART_MAIN);
    lv_obj_set_flex_flow(deck, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(deck, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);

    lv_obj_t *titleLbl = lv_label_create(deck);
    lv_label_set_text(titleLbl, titleText);
    lv_obj_set_style_text_font(titleLbl, &lv_font_montserrat_18, LV_PART_MAIN);
    lv_obj_set_style_text_color(titleLbl, lv_color_hex(GORE_BRIGHT_RED), LV_PART_MAIN);

    lv_obj_t *volLbl = lv_label_create(deck);
    lv_label_set_text(volLbl, "Volume");
    lv_obj_set_style_text_font(volLbl, &lv_font_montserrat_16, LV_PART_MAIN);

    mp3VolumeSlider[deckIndex] = lv_slider_create(deck);
    lv_obj_set_width(mp3VolumeSlider[deckIndex], 180);
    lv_slider_set_range(mp3VolumeSlider[deckIndex], 0, 255);
    lv_obj_add_event_cb(mp3VolumeSlider[deckIndex], mp3_volume_event_cb, LV_EVENT_RELEASED, &mp3DeckMap[deckIndex]);

    lv_obj_t *transportRow = lv_obj_create(deck);
    lv_obj_set_size(transportRow, 180, 60);
    lv_obj_set_style_bg_color(transportRow, lv_color_hex(GORE_PANEL_BG), LV_PART_MAIN);
    lv_obj_set_style_border_width(transportRow, 0, LV_PART_MAIN);
    lv_obj_set_style_pad_all(transportRow, 6, LV_PART_MAIN);
    lv_obj_set_style_radius(transportRow, 8, LV_PART_MAIN);
    lv_obj_set_flex_flow(transportRow, LV_FLEX_FLOW_ROW);
    lv_obj_set_flex_align(transportRow, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);

    lv_obj_t *playBtn = lv_btn_create(transportRow);
    lv_obj_set_size(playBtn, 70, 40);
    lv_obj_set_style_bg_color(playBtn, lv_color_hex(GORE_RED), LV_PART_MAIN);
    lv_obj_set_style_border_width(playBtn, 0, LV_PART_MAIN);
    lv_obj_set_style_radius(playBtn, 10, LV_PART_MAIN);
    lv_obj_t *playLbl = lv_label_create(playBtn);
    lv_label_set_text(playLbl, LV_SYMBOL_PLAY " PLAY");
    lv_obj_center(playLbl);
    mp3ButtonMeta[deckIndex * 2] = {deckIndex, MP3_ACT_PLAY};
    lv_obj_add_event_cb(playBtn, mp3_transport_event_cb, LV_EVENT_CLICKED, &mp3ButtonMeta[deckIndex * 2]);

    lv_obj_t *stopBtn = lv_btn_create(transportRow);
    lv_obj_set_size(stopBtn, 70, 40);
    lv_obj_set_style_bg_color(stopBtn, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);
    lv_obj_set_style_border_width(stopBtn, 0, LV_PART_MAIN);
    lv_obj_set_style_radius(stopBtn, 10, LV_PART_MAIN);
    lv_obj_t *stopLbl = lv_label_create(stopBtn);
    lv_label_set_text(stopLbl, LV_SYMBOL_STOP " STOP");
    lv_obj_center(stopLbl);
    mp3ButtonMeta[deckIndex * 2 + 1] = {deckIndex, MP3_ACT_STOP};
    lv_obj_add_event_cb(stopBtn, mp3_transport_event_cb, LV_EVENT_CLICKED, &mp3ButtonMeta[deckIndex * 2 + 1]);

    mp3StateLabel[deckIndex] = lv_label_create(deck);
    lv_label_set_text(mp3StateLabel[deckIndex], "State: STOP");
    lv_obj_set_style_text_font(mp3StateLabel[deckIndex], &lv_font_montserrat_16, LV_PART_MAIN);
  };

  build_mp3_deck(0, "MP3 DECK A");
  build_mp3_deck(1, "MP3 DECK B");

  lv_obj_t *ledPanel = lv_obj_create(lower_panel);
  lv_obj_set_size(ledPanel, 200, 150);
  lv_obj_set_style_bg_color(ledPanel, lv_color_hex(GORE_SLATE), LV_PART_MAIN);
  lv_obj_set_style_border_width(ledPanel, 0, LV_PART_MAIN);
  lv_obj_set_style_radius(ledPanel, 10, LV_PART_MAIN);
  lv_obj_set_style_pad_all(ledPanel, 10, LV_PART_MAIN);
  lv_obj_set_flex_flow(ledPanel, LV_FLEX_FLOW_COLUMN);
  lv_obj_set_flex_align(ledPanel, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);

  lv_obj_t *ledTitle = lv_label_create(ledPanel);
  lv_label_set_text(ledTitle, "LED LINES");
  lv_obj_set_style_text_font(ledTitle, &lv_font_montserrat_18, LV_PART_MAIN);
  lv_obj_set_style_text_color(ledTitle, lv_color_hex(GORE_BRIGHT_RED), LV_PART_MAIN);

  for (int i = 0; i < 4; ++i) {
    ledSlider[i] = lv_slider_create(ledPanel);
    lv_obj_set_width(ledSlider[i], 180);
    lv_slider_set_range(ledSlider[i], 0, 65535);
    lv_obj_add_event_cb(ledSlider[i], led_slider_event_cb, LV_EVENT_RELEASED, &ledLineMap[i]);

    char lbl[24];
    snprintf(lbl, sizeof(lbl), "Line %d", i + 1);
    lv_obj_t *lineLbl = lv_label_create(ledPanel);
    lv_label_set_text(lineLbl, lbl);
    lv_obj_set_style_text_font(lineLbl, &lv_font_montserrat_14, LV_PART_MAIN);
  }

  // Toolbar
  lv_obj_t *toolbar = lv_obj_create(screen_live_control);
  lv_obj_set_size(toolbar, SCREEN_W - 32, 70);
  lv_obj_align(toolbar, LV_ALIGN_BOTTOM_MID, 0, 0);
  lv_obj_set_style_bg_color(toolbar, lv_color_hex(GORE_SLATE), LV_PART_MAIN);
  lv_obj_set_style_border_width(toolbar, 0, LV_PART_MAIN);
  lv_obj_set_style_pad_all(toolbar, 10, LV_PART_MAIN);
  lv_obj_set_style_radius(toolbar, 12, LV_PART_MAIN);
  lv_obj_set_flex_flow(toolbar, LV_FLEX_FLOW_ROW);
  lv_obj_set_flex_align(toolbar, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);

  auto make_toolbar_btn = [&](const char *txt, CommandType type) {
    lv_obj_t *btn = lv_btn_create(toolbar);
    lv_obj_set_size(btn, 180, 50);
    lv_obj_set_style_bg_color(btn, lv_color_hex(GORE_RED), LV_PART_MAIN);
    lv_obj_set_style_border_width(btn, 0, LV_PART_MAIN);
    lv_obj_set_style_radius(btn, 10, LV_PART_MAIN);
    lv_obj_t *label = lv_label_create(btn);
    lv_label_set_text(label, txt);
    lv_obj_center(label);
    lv_obj_add_event_cb(btn, toolbar_event_cb, LV_EVENT_CLICKED, (void *)(uintptr_t)type);
  };

  make_toolbar_btn(LV_SYMBOL_STOP " STOP ALL", CMD_STOP_ALL);
  make_toolbar_btn(LV_SYMBOL_PLAY " NEXT CUE", CMD_NEXT_CUE);
  make_toolbar_btn(LV_SYMBOL_LEFT " PREV CUE", CMD_PREV_CUE);

  Serial.println("[UI] LIVE CONTROL ready");
}

// ────────────────────────────────────────────────────────────────
//  BUILDER HELPERS
// ────────────────────────────────────────────────────────────────
static void builder_attach_library_button(ShowEntry &entry) {
  if (!builder_show_list) return;

  entry.widget = lv_btn_create(builder_show_list);
  lv_obj_set_size(entry.widget, LV_PCT(100), 60);
  lv_obj_set_style_bg_color(entry.widget, lv_color_hex(GORE_SLATE), LV_PART_MAIN);
  lv_obj_set_style_bg_color(entry.widget, lv_color_hex(GORE_RED), LV_PART_MAIN | LV_STATE_PRESSED);
  lv_obj_set_style_radius(entry.widget, 10, LV_PART_MAIN);
  lv_obj_set_style_border_width(entry.widget, 0, LV_PART_MAIN);
  lv_obj_add_flag(entry.widget, LV_OBJ_FLAG_SCROLL_ON_FOCUS);
  lv_obj_add_event_cb(entry.widget, builder_show_item_event_cb, LV_EVENT_ALL, &entry);

  lv_obj_t *label = lv_label_create(entry.widget);
  lv_label_set_text(label, entry.name);
  lv_obj_center(label);

  entry.floating = false;
  entry.dragOffsetX = 0;
  entry.dragOffsetY = 0;
}

void builder_reset_show_item(ShowEntry *entry) {
  if (!entry || !entry->widget) return;
  if (builder_show_list) {
    lv_obj_remove_flag(entry->widget, LV_OBJ_FLAG_FLOATING);
    lv_obj_set_parent(entry->widget, builder_show_list);
    lv_obj_set_size(entry->widget, LV_PCT(100), 60);
    lv_obj_set_style_bg_color(entry->widget, lv_color_hex(GORE_SLATE), LV_PART_MAIN);
    lv_obj_move_to_index(entry->widget, builderShowCount > 0 ? builderShowCount - 1 : 0);
  }
  entry->floating = false;
}

void builder_clear_workspace() {
  for (size_t i = 0; i < builderClipCount; ++i) {
    if (builderClips[i].widget) {
      lv_obj_del(builderClips[i].widget);
      builderClips[i].widget = nullptr;
    }
  }
  builderClipCount = 0;
}

static bool builder_rect_overlap(const lv_area_t &a, const lv_area_t &b) {
  if (a.x2 < b.x1) return false;
  if (a.x1 > b.x2) return false;
  if (a.y2 < b.y1) return false;
  if (a.y1 > b.y2) return false;
  return true;
}

void builder_add_clip(const char *name, uint32_t startMs, uint8_t lane) {
  if (!builder_timeline_area) return;
  if (builderClipCount >= MAX_BUILDER_CLIPS) {
    if (builder_status_label) {
      lv_label_set_text(builder_status_label, "Clip limit reached (64)");
    }
    show_toast("Clip limit reached – delete a clip to add more", 2500);
    return;
  }

  BuilderClip &clip = builderClips[builderClipCount++];
  memset(&clip, 0, sizeof(clip));
  strncpy(clip.showName, name, sizeof(clip.showName) - 1);
  clip.startMs = min(startMs, builderTimelineMs);
  clip.lane = min<uint8_t>(lane, BUILDER_LANE_COUNT - 1);

  lv_obj_t *widget = lv_obj_create(builder_timeline_area);
  clip.widget = widget;
  lv_obj_set_size(widget, BUILDER_CLIP_WIDTH, BUILDER_CLIP_HEIGHT);
  lv_obj_set_style_bg_color(widget, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_radius(widget, 8, LV_PART_MAIN);
  lv_obj_set_style_border_color(widget, lv_color_hex(GORE_BRIGHT_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(widget, 2, LV_PART_MAIN);
  lv_obj_add_event_cb(widget, builder_clip_event_cb, LV_EVENT_CLICKED, &clip);

  lv_obj_t *label = lv_label_create(widget);
  lv_label_set_text(label, name);
  lv_obj_center(label);

  lv_coord_t innerWidth = lv_obj_get_width(builder_timeline_area) - BUILDER_CLIP_WIDTH - 20;
  if (innerWidth < 1) innerWidth = 1;
  lv_coord_t x = (lv_coord_t)((clip.startMs / (float)builderTimelineMs) * innerWidth);
  lv_coord_t y = clip.lane * BUILDER_LANE_HEIGHT + 10;
  lv_obj_set_pos(widget, x + 10, y);

  if (builder_status_label) {
    char msg[96];
    snprintf(msg, sizeof(msg), "Placed \"%s\" lane %u @ %lu ms", name,
             static_cast<unsigned>(clip.lane + 1),
             static_cast<unsigned long>(clip.startMs));
    lv_label_set_text(builder_status_label, msg);
  }
  show_toast("Cue added to timeline");
}

void refresh_show_library() {
  if (!builder_show_list) return;
  lv_obj_clean(builder_show_list);
  for (size_t i = 0; i < builderShowCount; ++i) {
    builderShowEntries[i].widget = nullptr;
  }

  load_show_library_from_storage();

  for (size_t i = 0; i < builderShowCount; ++i) {
    ShowEntry &entry = builderShowEntries[i];
    builder_attach_library_button(entry);
  }

  if (builder_status_label) {
    lv_label_set_text(builder_status_label, "Drag cues into the timeline to build a show.");
  }
}

void builder_show_item_event_cb(lv_event_t *e) {
  ShowEntry *entry = static_cast<ShowEntry *>(lv_event_get_user_data(e));
  if (!entry || !entry->widget) return;

  lv_event_code_t code = lv_event_get_code(e);
  lv_indev_t *indev = lv_indev_get_act();

  if (code == LV_EVENT_PRESSED && indev) {
    lv_area_t coords;
    lv_obj_get_coords(entry->widget, &coords);
    lv_point_t point;
    lv_indev_get_point(indev, &point);
    entry->homeX = coords.x1;
    entry->homeY = coords.y1;
    entry->dragOffsetX = point.x - coords.x1;
    entry->dragOffsetY = point.y - coords.y1;
    lv_obj_set_parent(entry->widget, screen_builder);
    lv_obj_add_flag(entry->widget, LV_OBJ_FLAG_FLOATING);
    lv_obj_move_foreground(entry->widget);
    lv_obj_set_size(entry->widget, BUILDER_CLIP_WIDTH, BUILDER_CLIP_HEIGHT);
    entry->floating = true;
  } else if (code == LV_EVENT_PRESSING && indev && entry->floating) {
    lv_point_t point;
    lv_indev_get_point(indev, &point);
    lv_coord_t newX = point.x - entry->dragOffsetX;
    lv_coord_t newY = point.y - entry->dragOffsetY;
    lv_obj_set_pos(entry->widget, newX, newY);
  } else if ((code == LV_EVENT_RELEASED || code == LV_EVENT_PRESS_LOST || code == LV_EVENT_DRAG_END) && entry->floating) {
    bool dropped = false;
    if (builder_timeline_area) {
      lv_area_t itemArea;
      lv_area_t timelineArea;
      lv_obj_get_coords(entry->widget, &itemArea);
      lv_obj_get_coords(builder_timeline_area, &timelineArea);
        if (builder_rect_overlap(itemArea, timelineArea)) {
          lv_coord_t timelineWidth = lv_obj_get_width(builder_timeline_area);
          lv_coord_t timelineSpan = timelineWidth - BUILDER_CLIP_WIDTH - 20;
          if (timelineSpan < 1) timelineSpan = 1;
          lv_coord_t relX = itemArea.x1 - (timelineArea.x1 + 10);
          lv_coord_t relY = itemArea.y1 - (timelineArea.y1 + 10);
          if (relX < 0) relX = 0;
          if (relX > timelineSpan) relX = timelineSpan;
          if (relY < 0) relY = 0;

          uint32_t startMs = (uint32_t)((relX / (float)timelineSpan) * builderTimelineMs);
          uint8_t lane = static_cast<uint8_t>(relY / BUILDER_LANE_HEIGHT);
          if (lane >= BUILDER_LANE_COUNT) lane = BUILDER_LANE_COUNT - 1;
          builder_add_clip(entry->name, startMs, lane);
          dropped = true;
        }
    }
    builder_reset_show_item(entry);
    if (!dropped) {
      if (builder_status_label) {
        lv_label_set_text(builder_status_label, "Cue returned to library.");
      }
      show_toast("Cue returned to library");
    }
  }
}

void builder_clip_event_cb(lv_event_t *e) {
  BuilderClip *clip = static_cast<BuilderClip *>(lv_event_get_user_data(e));
  if (!clip || !builder_status_label) return;
  lv_event_code_t code = lv_event_get_code(e);
  if (code == LV_EVENT_CLICKED) {
    char msg[96];
    snprintf(msg, sizeof(msg), "Clip \"%s\" lane %u @ %lu ms",
             clip->showName,
             static_cast<unsigned>(clip->lane + 1),
             static_cast<unsigned long>(clip->startMs));
    lv_label_set_text(builder_status_label, msg);
  }
}

void builder_clear_event_cb(lv_event_t *e) {
  (void)e;
  builder_clear_workspace();
  if (builder_status_label) {
    lv_label_set_text(builder_status_label, "Workspace cleared.");
  }
  show_toast("Builder workspace cleared");
}

void builder_save_event_cb(lv_event_t *e) {
  (void)e;
  if (!builder_name_field || !builder_status_label) return;

  const char *name = lv_textarea_get_text(builder_name_field);
  if (!name || strlen(name) == 0) {
    lv_label_set_text(builder_status_label, "Enter a show name before saving.");
    show_toast("Enter a show name before saving");
    return;
  }

  if (builderClipCount == 0) {
    lv_label_set_text(builder_status_label, "Add at least one clip before saving.");
    show_toast("Builder needs at least one cue before saving");
    return;
  }

  if (save_builder_to_storage(name)) {
    load_show_library_from_storage();
    refresh_show_library();
    lv_label_set_text(builder_status_label, "Show saved to SD card.");
    show_toast("Show arrangement saved to SD card");
    detach_keyboard();
  } else {
    lv_label_set_text(builder_status_label, "Failed to write show to SD card.");
    show_toast("Failed to save show – check SD card", 3000);
  }
}

// ────────────────────────────────────────────────────────────────
//  SETTINGS SCREEN
// ────────────────────────────────────────────────────────────────
void create_settings_screen() {
  Serial.println("[UI] Creating settings screen...");

  screen_settings = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(screen_settings, lv_color_hex(GORE_BLACK), LV_PART_MAIN);
  lv_obj_set_style_pad_all(screen_settings, 16, LV_PART_MAIN);
  lv_obj_set_scrollbar_mode(screen_settings, LV_SCROLLBAR_MODE_AUTO);

  lv_obj_t *header = lv_label_create(screen_settings);
  lv_label_set_text(header, LV_SYMBOL_SETTINGS " SETTINGS & LINK");
  lv_obj_set_style_text_color(header, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_text_font(header, &lv_font_montserrat_26, LV_PART_MAIN);
  lv_obj_align(header, LV_ALIGN_TOP_LEFT, 10, 10);

  lv_obj_t *btn_back = lv_btn_create(screen_settings);
  lv_obj_set_size(btn_back, 110, 48);
  lv_obj_align(btn_back, LV_ALIGN_TOP_RIGHT, -10, 6);
  lv_obj_set_style_bg_color(btn_back, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(btn_back, 0, LV_PART_MAIN);
  lv_obj_set_style_radius(btn_back, 10, LV_PART_MAIN);
  lv_obj_add_event_cb(btn_back, settings_back_event_cb, LV_EVENT_CLICKED, nullptr);

  lv_obj_t *label_back = lv_label_create(btn_back);
  lv_label_set_text(label_back, LV_SYMBOL_LEFT " BACK");
  lv_obj_center(label_back);

  lv_obj_t *content = lv_obj_create(screen_settings);
  lv_obj_set_size(content, SCREEN_W - 32, SCREEN_H - 120);
  lv_obj_align(content, LV_ALIGN_BOTTOM_MID, 0, 0);
  lv_obj_set_style_bg_color(content, lv_color_hex(GORE_PANEL_BG), LV_PART_MAIN);
  lv_obj_set_style_border_color(content, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(content, 2, LV_PART_MAIN);
  lv_obj_set_style_radius(content, 18, LV_PART_MAIN);
  lv_obj_set_style_pad_all(content, 16, LV_PART_MAIN);
  lv_obj_set_flex_flow(content, LV_FLEX_FLOW_COLUMN);
  lv_obj_set_flex_align(content, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
  lv_obj_set_style_pad_row(content, 20, LV_PART_MAIN);
  lv_obj_set_scroll_dir(content, LV_DIR_VER);

  auto make_card = [](lv_obj_t *parent) {
    lv_obj_t *card = lv_obj_create(parent);
    lv_obj_set_size(card, LV_PCT(100), LV_SIZE_CONTENT);
    lv_obj_set_style_bg_color(card, lv_color_hex(GORE_SLATE), LV_PART_MAIN);
    lv_obj_set_style_border_width(card, 0, LV_PART_MAIN);
    lv_obj_set_style_radius(card, 12, LV_PART_MAIN);
    lv_obj_set_style_pad_all(card, 14, LV_PART_MAIN);
    lv_obj_set_flex_flow(card, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(card, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
    lv_obj_set_style_pad_row(card, 8, LV_PART_MAIN);
    return card;
  };

  // Brightness card
  lv_obj_t *brightness_card = make_card(content);
  lv_obj_t *brightness_row = lv_obj_create(brightness_card);
  lv_obj_set_size(brightness_row, LV_PCT(100), LV_SIZE_CONTENT);
  lv_obj_set_style_bg_opa(brightness_row, LV_OPA_TRANSP, LV_PART_MAIN);
  lv_obj_set_style_border_width(brightness_row, 0, LV_PART_MAIN);
  lv_obj_set_style_pad_all(brightness_row, 0, LV_PART_MAIN);
  lv_obj_set_flex_flow(brightness_row, LV_FLEX_FLOW_ROW);
  lv_obj_set_flex_align(brightness_row, LV_FLEX_ALIGN_SPACE_BETWEEN, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);

  lv_obj_t *brightness_title = lv_label_create(brightness_row);
  lv_label_set_text(brightness_title, "Display Brightness");
  lv_obj_set_style_text_font(brightness_title, &lv_font_montserrat_20, LV_PART_MAIN);

  settings_brightness_value = lv_label_create(brightness_row);
  lv_obj_set_style_text_font(settings_brightness_value, &lv_font_montserrat_18, LV_PART_MAIN);

  settings_brightness_slider = lv_slider_create(brightness_card);
  lv_obj_set_width(settings_brightness_slider, LV_PCT(100));
  lv_slider_set_range(settings_brightness_slider, 10, 255);
  lv_slider_set_value(settings_brightness_slider, displayBrightness, LV_ANIM_OFF);
  lv_obj_add_event_cb(settings_brightness_slider, settings_brightness_event_cb, LV_EVENT_VALUE_CHANGED, nullptr);

  lv_obj_t *brightness_hint = lv_label_create(brightness_card);
  lv_label_set_text(brightness_hint, "Adjust TFT backlight intensity. Lower for dark FOH booths.");
  lv_obj_set_style_text_font(brightness_hint, &lv_font_montserrat_14, LV_PART_MAIN);
  lv_obj_set_style_text_color(brightness_hint, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);

  // Autopair card
  lv_obj_t *pair_card = make_card(content);
  lv_obj_t *pair_row = lv_obj_create(pair_card);
  lv_obj_set_size(pair_row, LV_PCT(100), LV_SIZE_CONTENT);
  lv_obj_set_style_bg_opa(pair_row, LV_OPA_TRANSP, LV_PART_MAIN);
  lv_obj_set_style_border_width(pair_row, 0, LV_PART_MAIN);
  lv_obj_set_style_pad_all(pair_row, 0, LV_PART_MAIN);
  lv_obj_set_flex_flow(pair_row, LV_FLEX_FLOW_ROW);
  lv_obj_set_flex_align(pair_row, LV_FLEX_ALIGN_SPACE_BETWEEN, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);

  lv_obj_t *pair_title = lv_label_create(pair_row);
  lv_label_set_text(pair_title, "Brain Auto-Pair");
  lv_obj_set_style_text_font(pair_title, &lv_font_montserrat_20, LV_PART_MAIN);

  settings_autopair_switch = lv_switch_create(pair_row);
  if (autoPairEnabled) {
    lv_obj_add_state(settings_autopair_switch, LV_STATE_CHECKED);
  } else {
    lv_obj_clear_state(settings_autopair_switch, LV_STATE_CHECKED);
  }
  lv_obj_add_event_cb(settings_autopair_switch, settings_autopair_event_cb, LV_EVENT_VALUE_CHANGED, nullptr);

  settings_autopair_label = lv_label_create(pair_card);
  lv_obj_set_style_text_font(settings_autopair_label, &lv_font_montserrat_16, LV_PART_MAIN);

  lv_obj_t *pair_hint = lv_label_create(pair_card);
  lv_label_set_text(pair_hint, "When enabled, the desk locks to the first Brain broadcasting status packets.");
  lv_obj_set_style_text_font(pair_hint, &lv_font_montserrat_14, LV_PART_MAIN);
  lv_obj_set_style_text_color(pair_hint, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);

  // TX power card
  lv_obj_t *power_card = make_card(content);
  lv_obj_t *power_row = lv_obj_create(power_card);
  lv_obj_set_size(power_row, LV_PCT(100), LV_SIZE_CONTENT);
  lv_obj_set_style_bg_opa(power_row, LV_OPA_TRANSP, LV_PART_MAIN);
  lv_obj_set_style_border_width(power_row, 0, LV_PART_MAIN);
  lv_obj_set_style_pad_all(power_row, 0, LV_PART_MAIN);
  lv_obj_set_flex_flow(power_row, LV_FLEX_FLOW_ROW);
  lv_obj_set_flex_align(power_row, LV_FLEX_ALIGN_SPACE_BETWEEN, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);

  lv_obj_t *power_title = lv_label_create(power_row);
  lv_label_set_text(power_title, "ESP-NOW TX Power");
  lv_obj_set_style_text_font(power_title, &lv_font_montserrat_20, LV_PART_MAIN);

  settings_txpower_value = lv_label_create(power_row);
  lv_obj_set_style_text_font(settings_txpower_value, &lv_font_montserrat_18, LV_PART_MAIN);

  settings_txpower_slider = lv_slider_create(power_card);
  lv_obj_set_width(settings_txpower_slider, LV_PCT(100));
  lv_slider_set_range(settings_txpower_slider, 8, 78);
  lv_slider_set_value(settings_txpower_slider, currentTxPower, LV_ANIM_OFF);
  lv_obj_add_event_cb(settings_txpower_slider, settings_txpower_event_cb, LV_EVENT_VALUE_CHANGED, nullptr);

  lv_obj_t *power_hint = lv_label_create(power_card);
  lv_label_set_text(power_hint, "Set RF output (dBm * 4). Reduce for short-range rehearsals to minimise noise.");
  lv_obj_set_style_text_font(power_hint, &lv_font_montserrat_14, LV_PART_MAIN);
  lv_obj_set_style_text_color(power_hint, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);

  // Link status card
  lv_obj_t *status_card = make_card(content);

  settings_channel_label = lv_label_create(status_card);
  lv_obj_set_style_text_font(settings_channel_label, &lv_font_montserrat_18, LV_PART_MAIN);

  settings_peer_label = lv_label_create(status_card);
  lv_obj_set_style_text_font(settings_peer_label, &lv_font_montserrat_18, LV_PART_MAIN);

  settings_last_status_label = lv_label_create(status_card);
  lv_obj_set_style_text_font(settings_last_status_label, &lv_font_montserrat_18, LV_PART_MAIN);

  settings_ping_label = lv_label_create(status_card);
  lv_obj_set_style_text_font(settings_ping_label, &lv_font_montserrat_18, LV_PART_MAIN);

  lv_obj_t *ping_btn = lv_btn_create(status_card);
  lv_obj_set_size(ping_btn, 180, 50);
  lv_obj_set_style_bg_color(ping_btn, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(ping_btn, 0, LV_PART_MAIN);
  lv_obj_set_style_radius(ping_btn, 10, LV_PART_MAIN);
  lv_obj_add_event_cb(ping_btn, settings_ping_event_cb, LV_EVENT_CLICKED, nullptr);

  lv_obj_t *ping_label = lv_label_create(ping_btn);
  lv_label_set_text(ping_label, LV_SYMBOL_REFRESH " PING BRAIN");
  lv_obj_center(ping_label);

  lv_obj_t *status_hint = lv_label_create(status_card);
  lv_label_set_text(status_hint, "Ping measures round-trip time against the next status frame from the Brain.");
  lv_obj_set_style_text_font(status_hint, &lv_font_montserrat_14, LV_PART_MAIN);
  lv_obj_set_style_text_color(status_hint, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);

  update_settings_telemetry();
  apply_display_brightness(displayBrightness);

  Serial.println("[UI] Settings screen ready");
}

// ────────────────────────────────────────────────────────────────
//  DIAGNOSTICS SCREEN
// ────────────────────────────────────────────────────────────────
void create_diagnostics_screen() {
  Serial.println("[UI] Creating diagnostics screen...");

  screen_diagnostics = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(screen_diagnostics, lv_color_hex(GORE_BLACK), LV_PART_MAIN);
  lv_obj_set_style_pad_all(screen_diagnostics, 16, LV_PART_MAIN);

  lv_obj_t *header = lv_label_create(screen_diagnostics);
  lv_label_set_text(header, LV_SYMBOL_LIST " LIVE DIAGNOSTICS");
  lv_obj_set_style_text_color(header, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_text_font(header, &lv_font_montserrat_26, LV_PART_MAIN);
  lv_obj_align(header, LV_ALIGN_TOP_LEFT, 10, 10);

  lv_obj_t *btn_back = lv_btn_create(screen_diagnostics);
  lv_obj_set_size(btn_back, 110, 48);
  lv_obj_align(btn_back, LV_ALIGN_TOP_RIGHT, -10, 6);
  lv_obj_set_style_bg_color(btn_back, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(btn_back, 0, LV_PART_MAIN);
  lv_obj_set_style_radius(btn_back, 10, LV_PART_MAIN);
  lv_obj_add_event_cb(btn_back, diagnostics_back_event_cb, LV_EVENT_CLICKED, nullptr);

  lv_obj_t *label_back = lv_label_create(btn_back);
  lv_label_set_text(label_back, LV_SYMBOL_LEFT " BACK");
  lv_obj_center(label_back);

  lv_obj_t *content = lv_obj_create(screen_diagnostics);
  lv_obj_set_size(content, SCREEN_W - 32, SCREEN_H - 120);
  lv_obj_align(content, LV_ALIGN_BOTTOM_MID, 0, 0);
  lv_obj_set_style_bg_color(content, lv_color_hex(GORE_PANEL_BG), LV_PART_MAIN);
  lv_obj_set_style_border_color(content, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(content, 2, LV_PART_MAIN);
  lv_obj_set_style_radius(content, 18, LV_PART_MAIN);
  lv_obj_set_style_pad_all(content, 18, LV_PART_MAIN);
  lv_obj_set_flex_flow(content, LV_FLEX_FLOW_COLUMN);
  lv_obj_set_flex_align(content, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
  lv_obj_set_style_pad_row(content, 18, LV_PART_MAIN);

  auto make_row = [](lv_obj_t *parent, const char *title, lv_obj_t **valueLabel) {
    lv_obj_t *row = lv_obj_create(parent);
    lv_obj_set_size(row, LV_PCT(100), LV_SIZE_CONTENT);
    lv_obj_set_style_bg_opa(row, LV_OPA_TRANSP, LV_PART_MAIN);
    lv_obj_set_style_border_width(row, 0, LV_PART_MAIN);
    lv_obj_set_style_pad_all(row, 0, LV_PART_MAIN);
    lv_obj_set_flex_flow(row, LV_FLEX_FLOW_ROW);
    lv_obj_set_flex_align(row, LV_FLEX_ALIGN_SPACE_BETWEEN, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);

    lv_obj_t *label = lv_label_create(row);
    lv_label_set_text(label, title);
    lv_obj_set_style_text_font(label, &lv_font_montserrat_20, LV_PART_MAIN);

    *valueLabel = lv_label_create(row);
    lv_obj_set_style_text_font(*valueLabel, &lv_font_montserrat_20, LV_PART_MAIN);
    lv_obj_set_style_text_color(*valueLabel, lv_color_hex(GORE_BRIGHT_RED), LV_PART_MAIN);

    return row;
  };

  make_row(content, "Mode", &diag_mode_label);
  make_row(content, "Relays", &diag_relay_label);
  make_row(content, "MP3 Decks", &diag_mp3_label);
  make_row(content, "LED Lines", &diag_led_label);
  make_row(content, "Timeline", &diag_timeline_label);
  make_row(content, "Last Status", &diag_last_update_label);

  lv_obj_t *button_row = lv_obj_create(content);
  lv_obj_set_size(button_row, LV_PCT(100), LV_SIZE_CONTENT);
  lv_obj_set_style_bg_opa(button_row, LV_OPA_TRANSP, LV_PART_MAIN);
  lv_obj_set_style_border_width(button_row, 0, LV_PART_MAIN);
  lv_obj_set_style_pad_all(button_row, 0, LV_PART_MAIN);
  lv_obj_set_flex_flow(button_row, LV_FLEX_FLOW_ROW);
  lv_obj_set_flex_align(button_row, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
  lv_obj_set_style_pad_column(button_row, 16, LV_PART_MAIN);

  lv_obj_t *btn_ping = lv_btn_create(button_row);
  lv_obj_set_size(btn_ping, 180, 50);
  lv_obj_set_style_bg_color(btn_ping, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_radius(btn_ping, 10, LV_PART_MAIN);
  lv_obj_add_event_cb(btn_ping, settings_ping_event_cb, LV_EVENT_CLICKED, nullptr);

  lv_obj_t *btn_ping_label = lv_label_create(btn_ping);
  lv_label_set_text(btn_ping_label, LV_SYMBOL_REFRESH " PING BRAIN");
  lv_obj_center(btn_ping_label);

  lv_obj_t *btn_resync = lv_btn_create(button_row);
  lv_obj_set_size(btn_resync, 200, 50);
  lv_obj_set_style_bg_color(btn_resync, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);
  lv_obj_set_style_radius(btn_resync, 10, LV_PART_MAIN);
  lv_obj_add_event_cb(btn_resync, pair_button_event_cb, LV_EVENT_CLICKED, nullptr);

  lv_obj_t *btn_resync_label = lv_label_create(btn_resync);
  lv_label_set_text(btn_resync_label, LV_SYMBOL_REFRESH " FORCE RE-PAIR");
  lv_obj_center(btn_resync_label);

  lv_obj_t *hint = lv_label_create(content);
  lv_label_set_text(hint, "Diagnostics mirrors the latest status frame. Use RE-PAIR to drop the current Brain and wait for a fresh handshake.");
  lv_obj_set_style_text_font(hint, &lv_font_montserrat_16, LV_PART_MAIN);
  lv_obj_set_style_text_color(hint, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);

  update_diagnostics_panel(latestStatus);

  Serial.println("[UI] Diagnostics screen ready");
}

// ────────────────────────────────────────────────────────────────
//  BUILDER SCREEN
// ────────────────────────────────────────────────────────────────
void create_builder_screen() {
  Serial.println("[UI] Creating DAW-style builder...");

  screen_builder = lv_obj_create(NULL);
  lv_obj_set_style_bg_color(screen_builder, lv_color_hex(GORE_BLACK), LV_PART_MAIN);
  lv_obj_set_style_pad_all(screen_builder, 12, LV_PART_MAIN);
  lv_obj_set_scrollbar_mode(screen_builder, LV_SCROLLBAR_MODE_OFF);

  lv_obj_t *top_bar = lv_obj_create(screen_builder);
  lv_obj_set_size(top_bar, SCREEN_W - 24, 90);
  lv_obj_align(top_bar, LV_ALIGN_TOP_MID, 0, 0);
  lv_obj_set_style_bg_color(top_bar, lv_color_hex(GORE_SLATE), LV_PART_MAIN);
  lv_obj_set_style_border_width(top_bar, 0, LV_PART_MAIN);
  lv_obj_set_style_radius(top_bar, 12, LV_PART_MAIN);
  lv_obj_set_style_pad_all(top_bar, 12, LV_PART_MAIN);
  lv_obj_set_flex_flow(top_bar, LV_FLEX_FLOW_ROW);
  lv_obj_set_flex_align(top_bar, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);

  lv_obj_t *title = lv_label_create(top_bar);
  lv_label_set_text(title, "SHOW BUILDER");
  lv_obj_set_style_text_font(title, &lv_font_montserrat_22, LV_PART_MAIN);
  lv_obj_set_style_text_color(title, lv_color_hex(GORE_BRIGHT_RED), LV_PART_MAIN);

  builder_name_field = lv_textarea_create(top_bar);
  lv_obj_set_size(builder_name_field, 200, 40);
  lv_textarea_set_placeholder_text(builder_name_field, "Show Name");
  lv_textarea_set_one_line(builder_name_field, true);
  lv_obj_add_event_cb(builder_name_field, [](lv_event_t *evt) {
    if (evt->code == LV_EVENT_FOCUSED) {
      attach_keyboard(builder_name_field);
    } else if (evt->code == LV_EVENT_DEFOCUSED) {
      detach_keyboard();
    }
  }, LV_EVENT_ALL, nullptr);

  lv_obj_t *btn_save = lv_btn_create(top_bar);
  builder_save_button = btn_save;
  lv_obj_set_size(btn_save, 140, 44);
  lv_obj_set_style_bg_color(btn_save, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_radius(btn_save, 10, LV_PART_MAIN);
  lv_obj_add_event_cb(btn_save, builder_save_event_cb, LV_EVENT_CLICKED, nullptr);
  lv_obj_t *save_label = lv_label_create(btn_save);
  lv_label_set_text(save_label, LV_SYMBOL_DOWNLOAD " SAVE");
  lv_obj_center(save_label);

  lv_obj_t *btn_clear = lv_btn_create(top_bar);
  lv_obj_set_size(btn_clear, 120, 44);
  lv_obj_set_style_bg_color(btn_clear, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);
  lv_obj_set_style_radius(btn_clear, 10, LV_PART_MAIN);
  lv_obj_add_event_cb(btn_clear, builder_clear_event_cb, LV_EVENT_CLICKED, nullptr);
  lv_obj_t *clear_label = lv_label_create(btn_clear);
  lv_label_set_text(clear_label, LV_SYMBOL_TRASH " CLEAR");
  lv_obj_center(clear_label);

  lv_obj_t *btn_back = lv_btn_create(top_bar);
  lv_obj_set_size(btn_back, 110, 44);
  lv_obj_set_style_bg_color(btn_back, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_radius(btn_back, 10, LV_PART_MAIN);
  lv_obj_add_event_cb(btn_back, settings_back_event_cb, LV_EVENT_CLICKED, nullptr);
  lv_obj_t *back_label = lv_label_create(btn_back);
  lv_label_set_text(back_label, LV_SYMBOL_LEFT " BACK");
  lv_obj_center(back_label);

  builder_library_panel = lv_obj_create(screen_builder);
  lv_obj_set_size(builder_library_panel, 240, SCREEN_H - 150);
  lv_obj_align(builder_library_panel, LV_ALIGN_TOP_LEFT, 0, 100);
  lv_obj_set_style_bg_color(builder_library_panel, lv_color_hex(GORE_PANEL_BG), LV_PART_MAIN);
  lv_obj_set_style_border_color(builder_library_panel, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(builder_library_panel, 2, LV_PART_MAIN);
  lv_obj_set_style_radius(builder_library_panel, 12, LV_PART_MAIN);
  lv_obj_set_style_pad_all(builder_library_panel, 12, LV_PART_MAIN);
  lv_obj_set_style_pad_row(builder_library_panel, 8, LV_PART_MAIN);
  lv_obj_set_flex_flow(builder_library_panel, LV_FLEX_FLOW_COLUMN);
  lv_obj_set_flex_align(builder_library_panel, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);

  lv_obj_t *library_title = lv_label_create(builder_library_panel);
  lv_label_set_text(library_title, "FX LIBRARY");
  lv_obj_set_style_text_font(library_title, &lv_font_montserrat_18, LV_PART_MAIN);
  lv_obj_set_style_text_color(library_title, lv_color_hex(GORE_BRIGHT_RED), LV_PART_MAIN);

  builder_show_list = lv_obj_create(builder_library_panel);
  lv_obj_set_size(builder_show_list, LV_PCT(100), LV_PCT(100));
  lv_obj_set_style_pad_all(builder_show_list, 8, LV_PART_MAIN);
  lv_obj_set_style_bg_opa(builder_show_list, LV_OPA_TRANSP, LV_PART_MAIN);
  lv_obj_set_scroll_dir(builder_show_list, LV_DIR_VER);
  lv_obj_set_flex_flow(builder_show_list, LV_FLEX_FLOW_COLUMN);
  lv_obj_set_flex_align(builder_show_list, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
  lv_obj_set_style_pad_row(builder_show_list, 6, LV_PART_MAIN);
  lv_obj_set_flex_grow(builder_show_list, 1);

  builder_timeline_area = lv_obj_create(screen_builder);
  lv_obj_set_size(builder_timeline_area, SCREEN_W - 280, SCREEN_H - 150);
  lv_obj_align(builder_timeline_area, LV_ALIGN_TOP_RIGHT, 0, 100);
  lv_obj_set_style_bg_color(builder_timeline_area, lv_color_hex(GORE_PANEL_BG), LV_PART_MAIN);
  lv_obj_set_style_border_color(builder_timeline_area, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_border_width(builder_timeline_area, 2, LV_PART_MAIN);
  lv_obj_set_style_radius(builder_timeline_area, 12, LV_PART_MAIN);
  lv_obj_set_style_pad_all(builder_timeline_area, 10, LV_PART_MAIN);

  for (uint8_t lane = 0; lane < BUILDER_LANE_COUNT; ++lane) {
    lv_obj_t *lane_line = lv_obj_create(builder_timeline_area);
    lv_obj_set_size(lane_line, LV_PCT(100), 2);
    lv_obj_set_style_bg_color(lane_line, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);
    lv_obj_set_style_border_width(lane_line, 0, LV_PART_MAIN);
    lv_obj_clear_flag(lane_line, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_align(lane_line, LV_ALIGN_TOP_LEFT, 0, lane * BUILDER_LANE_HEIGHT);

    lv_obj_t *lane_label = lv_label_create(builder_timeline_area);
    char laneText[16];
    snprintf(laneText, sizeof(laneText), "Lane %u", static_cast<unsigned>(lane + 1));
    lv_label_set_text(lane_label, laneText);
    lv_obj_set_style_text_font(lane_label, &lv_font_montserrat_16, LV_PART_MAIN);
    lv_obj_set_style_text_color(lane_label, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);
    lv_obj_align(lane_label, LV_ALIGN_TOP_LEFT, 4, lane * BUILDER_LANE_HEIGHT + 6);
  }

  builder_status_label = lv_label_create(screen_builder);
  lv_label_set_text(builder_status_label, "Drag cues into the timeline to build a show.");
  lv_obj_set_style_text_font(builder_status_label, &lv_font_montserrat_16, LV_PART_MAIN);
  lv_obj_align(builder_status_label, LV_ALIGN_BOTTOM_LEFT, 10, -10);

  toast_container = lv_obj_create(screen_builder);
  lv_obj_set_size(toast_container, SCREEN_W - 80, 60);
  lv_obj_align(toast_container, LV_ALIGN_BOTTOM_MID, 0, -20);
  lv_obj_set_style_bg_color(toast_container, lv_color_hex(GORE_RED), LV_PART_MAIN);
  lv_obj_set_style_bg_opa(toast_container, LV_OPA_60, LV_PART_MAIN);
  lv_obj_set_style_radius(toast_container, 12, LV_PART_MAIN);
  lv_obj_set_style_border_width(toast_container, 0, LV_PART_MAIN);
  lv_obj_set_style_pad_all(toast_container, 12, LV_PART_MAIN);
  lv_obj_add_flag(toast_container, LV_OBJ_FLAG_HIDDEN);

  lv_obj_t *toast_label = lv_label_create(toast_container);
  lv_label_set_text(toast_label, "");
  lv_obj_set_style_text_font(toast_label, &lv_font_montserrat_18, LV_PART_MAIN);
  lv_obj_set_style_text_align(toast_label, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN);
  lv_obj_center(toast_label);

  builder_clear_workspace();
  load_show_library_from_storage();
  refresh_show_library();

  Serial.println("[UI] Builder screen ready");
}

// ────────────────────────────────────────────────────────────────
//  UI BUILD PIPELINE (Deferred)
// ────────────────────────────────────────────────────────────────
void build_ui_incremental() {
  switch (uiStage) {
    case 0:
      Serial.println("[UI] Stage 0 → Main menu");
      create_main_menu();
      uiStage++;
      break;
    case 1:
      Serial.println("[UI] Stage 1 → Timeline");
      create_timeline_screen();
      uiStage++;
      break;
    case 2:
      Serial.println("[UI] Stage 2 → FX Designer");
      create_fx_designer_screen();
      uiStage++;
      break;
    case 3:
      Serial.println("[UI] Stage 3 → Live Control");
      create_live_control_screen();
      uiStage++;
      break;
    case 4:
      Serial.println("[UI] Stage 4 → Settings");
      create_settings_screen();
      uiStage++;
      break;
    case 5:
      Serial.println("[UI] Stage 5 → Builder");
      create_builder_screen();
      uiStage++;
      break;
    case 6:
      Serial.println("[UI] Stage 6 → Diagnostics");
      create_diagnostics_screen();
      uiStage++;
      break;
    case 7:
      Serial.println("[UI] ✓ All screens created");
      uiCreated = true;
      uiStage++;
      break;
    default:
      break;
  }
}

// ────────────────────────────────────────────────────────────────
//  ESP-NOW INITIALISATION
// ────────────────────────────────────────────────────────────────
bool init_esp_now() {
  Serial.println("[ESP-NOW] Initialising radio…");

  WiFi.mode(WIFI_STA);
  WiFi.disconnect();
  esp_wifi_set_channel(SHOWDUINO_ESPNOW_CHANNEL, WIFI_SECOND_CHAN_NONE);
  esp_wifi_set_ps(WIFI_PS_NONE);
  esp_wifi_set_max_tx_power(SHOWDUINO_MAX_TX_POWER);
  esp_wifi_config_espnow_rate(WIFI_IF_STA, WIFI_PHY_RATE_MCS7_SGI);
  currentChannel = SHOWDUINO_ESPNOW_CHANNEL;
  currentTxPower = SHOWDUINO_MAX_TX_POWER;

  if (esp_now_init() != ESP_OK) {
    Serial.println("[ESP-NOW] ❌ esp_now_init failed");
    return false;
  }

  esp_now_register_recv_cb(on_espnow_recv);
  esp_now_register_send_cb(on_espnow_sent);
  espNowReady = true;

  // Allow broadcast status reception before pairing
  esp_now_peer_info_t peerInfo = {};
  memset(peerInfo.peer_addr, 0xFF, 6);
  peerInfo.channel = SHOWDUINO_ESPNOW_CHANNEL;
  peerInfo.ifidx = WIFI_IF_STA;
  peerInfo.encrypt = false;
  esp_now_add_peer(&peerInfo);

  Serial.printf("[ESP-NOW] Ready on channel %u / TX power %d\n",
                SHOWDUINO_ESPNOW_CHANNEL, SHOWDUINO_MAX_TX_POWER);
  return true;
}

// ────────────────────────────────────────────────────────────────
//  ESP-NOW PEER MANAGEMENT
// ────────────────────────────────────────────────────────────────
void forget_brain_peer() {
  if (brainPeerKnown) {
    esp_now_del_peer(brainPeerMac);
    memset(brainPeerMac, 0, sizeof(brainPeerMac));
    brainPeerKnown = false;
    Serial.println("[ESP-NOW] Cleared paired Brain");
  }
}

bool ensure_peer_registered(const uint8_t *mac) {
  if (!mac) return false;

  if (brainPeerKnown && memcmp(mac, brainPeerMac, 6) == 0) {
    return true;
  }

  if (!autoPairEnabled) {
    if (!brainPeerKnown) {
      Serial.println("[ESP-NOW] Auto-pair disabled – ignoring unknown Brain");
      return false;
    }
    // Already paired with a different MAC: hold lock, ignore newcommer
    return false;
  }

  // New peer or changed MAC
  if (brainPeerKnown) {
    esp_now_del_peer(brainPeerMac);
  }

  esp_now_peer_info_t peerInfo = {};
  memcpy(peerInfo.peer_addr, mac, 6);
  memcpy(brainPeerMac, mac, 6);
  peerInfo.channel = SHOWDUINO_ESPNOW_CHANNEL;
  peerInfo.ifidx = WIFI_IF_STA;
  peerInfo.encrypt = false;

  esp_err_t res = esp_now_add_peer(&peerInfo);
  if (res != ESP_OK) {
    Serial.printf("[ESP-NOW] ❌ Failed to register peer (err=%d)\n", res);
    return false;
  }

  brainPeerKnown = true;
  char macStr[24];
  snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X",
           mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  Serial.printf("[ESP-NOW] Paired with Brain %s\n", macStr);
  return true;
}

// ────────────────────────────────────────────────────────────────
//  ESP-NOW CALLBACKS
// ────────────────────────────────────────────────────────────────
void on_espnow_recv(const uint8_t *mac, const uint8_t *incomingData, int len) {
  if (len < (int)sizeof(ShowduinoStatus)) {
    return;
  }

  if (!ensure_peer_registered(mac)) {
    if (!brainPeerKnown || memcmp(mac, brainPeerMac, 6) != 0) {
      return;
    }
  }

  portENTER_CRITICAL_ISR(&statusMux);
  memcpy(&statusBuffer, incomingData, sizeof(ShowduinoStatus));
  statusAvailable = true;
  portEXIT_CRITICAL_ISR(&statusMux);

  lastStatusMillis = millis();
}

void on_espnow_sent(const uint8_t *mac, esp_now_send_status_t status) {
  lastSendStatus = status;
  lastSendMillis = millis();
}

// ────────────────────────────────────────────────────────────────
//  COMMAND DISPATCHER
// ────────────────────────────────────────────────────────────────
bool send_showduino_command(const ShowduinoCommand &cmd) {
  if (!espNowReady) {
    Serial.println("[ESP-NOW] Link not ready, command dropped");
    return false;
  }
  if (!brainPeerKnown) {
    Serial.println("[ESP-NOW] No Brain paired, command dropped");
    return false;
  }

  esp_err_t res = esp_now_send(brainPeerMac, reinterpret_cast<const uint8_t *>(&cmd), sizeof(cmd));
  if (res != ESP_OK) {
    Serial.printf("[ESP-NOW] ❌ Send failed (err=%d)\n", res);
    return false;
  }
  return true;
}

void send_timeline_command(CommandType type, uint32_t position, uint16_t value) {
  ShowduinoCommand cmd{};
  cmd.type = type;
  cmd.position = position;
  if (type == CMD_TIMELINE_LOOP) {
    cmd.value = timelineLoopEnabled ? 1 : 0;
  } else {
    cmd.value = value;
  }
  if (!send_showduino_command(cmd)) {
    show_toast("Failed to send timeline command", 2500);
  }
}

// ────────────────────────────────────────────────────────────────
//  STATUS PROCESSING
// ────────────────────────────────────────────────────────────────
void handle_status_queue() {
  bool hasUpdate = false;
  ShowduinoStatus pending{};

  portENTER_CRITICAL(&statusMux);
  if (statusAvailable) {
    pending = statusBuffer;
    statusAvailable = false;
    hasUpdate = true;
  }
  portEXIT_CRITICAL(&statusMux);

  if (hasUpdate) {
    latestStatus = pending;
    if (pingPending) {
      lastPingRoundtrip = millis() - lastPingSendMillis;
      pingPending = false;
    }
    update_live_controls(latestStatus);
    update_diagnostics_panel(latestStatus);
    update_link_indicator();
  }
}

// ────────────────────────────────────────────────────────────────
//  UTILS
// ────────────────────────────────────────────────────────────────
void init_backlight_pwm() {
  ledcSetup(BACKLIGHT_PWM_CHANNEL, BACKLIGHT_PWM_FREQ, BACKLIGHT_PWM_RESOLUTION);
  ledcAttachPin(TFT_BL, BACKLIGHT_PWM_CHANNEL);
  apply_display_brightness(displayBrightness);
}

void apply_display_brightness(uint8_t level) {
  displayBrightness = constrain(level, 0, 255);
  uint32_t dutyMax = (1u << BACKLIGHT_PWM_RESOLUTION) - 1;
  uint32_t duty = map(displayBrightness, 0, 255, 0, dutyMax);
  ledcWrite(BACKLIGHT_PWM_CHANNEL, duty);

  if (settings_brightness_value) {
    char buf[8];
    snprintf(buf, sizeof(buf), "%u%%", (displayBrightness * 100) / 255);
    lv_label_set_text(settings_brightness_value, buf);
  }

  if (settings_brightness_slider) {
    updatingSettingsUi = true;
    lv_slider_set_value(settings_brightness_slider, displayBrightness, LV_ANIM_OFF);
    updatingSettingsUi = false;
  }
}

void format_timecode(uint32_t ms, char *buffer, size_t len) {
  uint32_t totalSeconds = ms / 1000;
  uint32_t minutes = totalSeconds / 60;
  uint32_t seconds = totalSeconds % 60;
  uint32_t tenths = (ms % 1000) / 100;
  snprintf(buffer, len, "%02lu:%02lu.%01lu", minutes, seconds, tenths);
}

void refresh_timeline_readout(uint32_t position) {
  if (!live_timeline_label) return;
  char buf[16];
  format_timecode(position, buf, sizeof(buf));
  lv_label_set_text(live_timeline_label, buf);
}

void update_mp3_state_label(uint8_t deck, uint8_t state) {
  if (deck >= 2 || !mp3StateLabel[deck]) return;
  if (state) {
    lv_label_set_text(mp3StateLabel[deck], "State: PLAY");
  } else {
    lv_label_set_text(mp3StateLabel[deck], "State: STOP");
  }
}

void update_live_controls(const ShowduinoStatus &status) {
  if (!screen_live_control) return;
  updatingFromStatus = true;

  if (live_mode_btn) {
    if (status.mode == MODE_MANUAL) {
      lv_obj_add_state(live_mode_btn, LV_STATE_CHECKED);
      if (live_mode_label) lv_label_set_text(live_mode_label, "MANUAL");
    } else {
      lv_obj_clear_state(live_mode_btn, LV_STATE_CHECKED);
      if (live_mode_label) lv_label_set_text(live_mode_label, "MONITOR");
    }
  }

  for (int i = 0; i < 8; ++i) {
    if (!relayButtons[i]) continue;
    if (status.relays[i]) {
      lv_obj_add_state(relayButtons[i], LV_STATE_CHECKED);
    } else {
      lv_obj_clear_state(relayButtons[i], LV_STATE_CHECKED);
    }
  }

  for (int deck = 0; deck < 2; ++deck) {
    if (mp3VolumeSlider[deck]) {
      lv_slider_set_value(mp3VolumeSlider[deck], status.mp3Vol[deck], LV_ANIM_OFF);
    }
    update_mp3_state_label(deck, status.mp3State[deck]);
  }

  for (int i = 0; i < 4; ++i) {
    if (ledSlider[i]) {
      lv_slider_set_value(ledSlider[i], status.ledBrightness[i], LV_ANIM_OFF);
    }
  }

  if (live_timeline_slider) {
    uint32_t clamped = min(status.timelinePos, TIMELINE_MAX_MS);
    lv_slider_set_value(live_timeline_slider, clamped, LV_ANIM_OFF);
    refresh_timeline_readout(clamped);
  }

  if (live_cue_label) {
    char buf[32];
    snprintf(buf, sizeof(buf), "Cue: %u", status.activeCue);
    lv_label_set_text(live_cue_label, buf);
  }

  updatingFromStatus = false;
}

void update_link_indicator() {
  if (!live_signal_label || !live_peer_label) return;

  if (!brainPeerKnown) {
    lv_label_set_text(live_signal_label, LV_SYMBOL_WIFI " NO LINK");
    lv_obj_set_style_text_color(live_signal_label, lv_color_hex(GORE_DARK_RED), LV_PART_MAIN);
    lv_label_set_text(live_peer_label, "Waiting for Brain...");
    update_settings_telemetry();
    return;
  }

  uint32_t now = millis();
  uint32_t age = (lastStatusMillis == 0) ? UINT32_MAX : now - lastStatusMillis;

  if (age < LINK_STALE_MS) {
    lv_label_set_text(live_signal_label, LV_SYMBOL_WIFI " LINK OK");
    lv_obj_set_style_text_color(live_signal_label, lv_color_hex(0x00FF00), LV_PART_MAIN);
  } else if (age < LINK_LOST_MS) {
    lv_label_set_text(live_signal_label, LV_SYMBOL_WIFI " STALE");
    lv_obj_set_style_text_color(live_signal_label, lv_color_hex(0xFFA500), LV_PART_MAIN);
  } else {
    lv_label_set_text(live_signal_label, LV_SYMBOL_WARNING " LOST");
    lv_obj_set_style_text_color(live_signal_label, lv_color_hex(GORE_BRIGHT_RED), LV_PART_MAIN);
  }

  char macStr[32];
  snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X",
           brainPeerMac[0], brainPeerMac[1], brainPeerMac[2],
           brainPeerMac[3], brainPeerMac[4], brainPeerMac[5]);
  lv_label_set_text(live_peer_label, macStr);
  update_settings_telemetry();
}

void update_settings_telemetry() {
  uint32_t now = millis();

  if (settings_autopair_switch) {
    updatingSettingsUi = true;
    if (autoPairEnabled) {
      lv_obj_add_state(settings_autopair_switch, LV_STATE_CHECKED);
    } else {
      lv_obj_clear_state(settings_autopair_switch, LV_STATE_CHECKED);
    }
    updatingSettingsUi = false;
  }

  if (settings_autopair_label) {
    lv_label_set_text_fmt(settings_autopair_label, "Auto-Pair: %s",
                          autoPairEnabled ? "Enabled (listen & lock)" : "Manual (hold paired Brain)");
  }

  if (settings_txpower_slider) {
    updatingSettingsUi = true;
    lv_slider_set_value(settings_txpower_slider, currentTxPower, LV_ANIM_OFF);
    updatingSettingsUi = false;
  }

  if (settings_txpower_value) {
    float dbm = currentTxPower / 4.0f;
    lv_label_set_text_fmt(settings_txpower_value, "%d (%.1f dBm)", currentTxPower, dbm);
  }

  if (settings_channel_label) {
    lv_label_set_text_fmt(settings_channel_label, "Channel: %u  • PHY: MCS7 (Short GI)",
                          currentChannel);
  }

  if (settings_peer_label) {
    if (brainPeerKnown) {
      lv_label_set_text_fmt(settings_peer_label, "Paired Brain: %02X:%02X:%02X:%02X:%02X:%02X",
                            brainPeerMac[0], brainPeerMac[1], brainPeerMac[2],
                            brainPeerMac[3], brainPeerMac[4], brainPeerMac[5]);
    } else {
      lv_label_set_text(settings_peer_label, "Paired Brain: (none)");
    }
  }

  if (settings_last_status_label) {
    if (lastStatusMillis == 0) {
      lv_label_set_text(settings_last_status_label, "Last Status: none received");
    } else {
      uint32_t age = now - lastStatusMillis;
      lv_label_set_text_fmt(settings_last_status_label, "Last Status: %lu ms ago", static_cast<unsigned long>(age));
    }
  }

  if (settings_ping_label) {
    if (pingPending) {
      uint32_t elapsed = now - lastPingSendMillis;
      if (elapsed > 5000) {
        pingPending = false;
        lastPingRoundtrip = 0;
        lv_label_set_text(settings_ping_label, "Ping: timeout (>5s)");
      } else {
        lv_label_set_text_fmt(settings_ping_label, "Ping: pending (%lu ms)", static_cast<unsigned long>(elapsed));
      }
    } else if (lastPingRoundtrip > 0) {
      lv_label_set_text_fmt(settings_ping_label, "Ping: %lu ms round-trip", static_cast<unsigned long>(lastPingRoundtrip));
    } else {
      lv_label_set_text(settings_ping_label, "Ping: not run");
    }
  }
}

void update_diagnostics_panel(const ShowduinoStatus &status) {
  if (!diag_mode_label) return;

  if (lastStatusMillis == 0) {
    lv_label_set_text(diag_mode_label, "--");
    if (diag_relay_label) lv_label_set_text(diag_relay_label, "--");
    if (diag_mp3_label) lv_label_set_text(diag_mp3_label, "--");
    if (diag_led_label) lv_label_set_text(diag_led_label, "--");
    if (diag_timeline_label) lv_label_set_text(diag_timeline_label, "--");
    if (diag_last_update_label) lv_label_set_text(diag_last_update_label, "Last Status: none");
    return;
  }

  const char *modeStr = status.mode == MODE_MANUAL ? "MANUAL (desk override)" : "AUTO (timeline)";
  lv_label_set_text(diag_mode_label, modeStr);

  if (diag_relay_label) {
    char buf[64];
    char *ptr = buf;
    for (size_t i = 0; i < 8; ++i) {
      ptr += snprintf(ptr, sizeof(buf) - (ptr - buf), "%u%s", status.relays[i],
                      (i < 7) ? " " : "");
    }
    lv_label_set_text(diag_relay_label, buf);
  }

  if (diag_mp3_label) {
    char buf[80];
    const char *stateA = status.mp3State[0] ? "PLAY" : "STOP";
    const char *stateB = status.mp3State[1] ? "PLAY" : "STOP";
    snprintf(buf, sizeof(buf), "A:%u/%s  B:%u/%s",
             status.mp3Vol[0], stateA, status.mp3Vol[1], stateB);
    lv_label_set_text(diag_mp3_label, buf);
  }

  if (diag_led_label) {
    char buf[96];
    snprintf(buf, sizeof(buf), "%u  %u  %u  %u",
             status.ledBrightness[0], status.ledBrightness[1],
             status.ledBrightness[2], status.ledBrightness[3]);
    lv_label_set_text(diag_led_label, buf);
  }

  if (diag_timeline_label) {
    char timecode[16];
    format_timecode(status.timelinePos, timecode, sizeof(timecode));
    lv_label_set_text_fmt(diag_timeline_label, "Cue %u @ %s", status.activeCue, timecode);
  }

  if (diag_last_update_label) {
    if (lastStatusMillis == 0) {
      lv_label_set_text(diag_last_update_label, "Last Status: none");
    } else {
      uint32_t age = millis() - lastStatusMillis;
      lv_label_set_text_fmt(diag_last_update_label, "Last Status: %lu ms ago",
                            static_cast<unsigned long>(age));
    }
  }
}

// ────────────────────────────────────────────────────────────────
//  EVENT HANDLERS
// ────────────────────────────────────────────────────────────────
void mode_toggle_event_cb(lv_event_t *e) {
  if (updatingFromStatus) return;
  lv_obj_t *btn = lv_event_get_target(e);
  bool manual = lv_obj_has_state(btn, LV_STATE_CHECKED);
  if (live_mode_label) lv_label_set_text(live_mode_label, manual ? "MANUAL" : "MONITOR");

  ShowduinoCommand cmd{};
  cmd.type = CMD_CONTROL_MODE;
  cmd.value = manual ? MODE_MANUAL : MODE_AUTO;
  send_showduino_command(cmd);
}

void timeline_event_cb(lv_event_t *e) {
  lv_obj_t *slider = lv_event_get_target(e);
  uint32_t position = lv_slider_get_value(slider);

  if (e->code == LV_EVENT_VALUE_CHANGED) {
    refresh_timeline_readout(position);
    if (updatingFromStatus) return;
    // Preview seek while dragging
    ShowduinoCommand preview{};
    preview.type = CMD_TIMELINE_PREVIEW;
    preview.position = position;
    send_showduino_command(preview);
  } else if (e->code == LV_EVENT_RELEASED) {
    if (updatingFromStatus) return;
    ShowduinoCommand play{};
    play.type = CMD_TIMELINE_PLAY;
    play.position = position;
    send_showduino_command(play);
  }
}

void relay_event_cb(lv_event_t *e) {
  if (updatingFromStatus) return;
  lv_obj_t *btn = lv_event_get_target(e);
  const uint8_t *relayIdPtr = static_cast<const uint8_t *>(lv_event_get_user_data(e));
  if (!relayIdPtr) return;
  bool state = lv_obj_has_state(btn, LV_STATE_CHECKED);

  ShowduinoCommand cmd{};
  cmd.type = CMD_RELAY;
  cmd.id = *relayIdPtr;
  cmd.value = state ? 1 : 0;
  send_showduino_command(cmd);
}

void mp3_volume_event_cb(lv_event_t *e) {
  if (updatingFromStatus) return;
  const uint8_t *deckPtr = static_cast<const uint8_t *>(lv_event_get_user_data(e));
  if (!deckPtr) return;
  uint16_t volume = lv_slider_get_value(lv_event_get_target(e));

  ShowduinoCommand cmd{};
  cmd.type = CMD_MP3_VOLUME;
  cmd.id = *deckPtr;
  cmd.value = volume;
  send_showduino_command(cmd);
}

void mp3_transport_event_cb(lv_event_t *e) {
  const Mp3ButtonMeta *meta = static_cast<const Mp3ButtonMeta *>(lv_event_get_user_data(e));
  if (!meta) return;

  ShowduinoCommand cmd{};
  cmd.id = meta->deck;

  if (meta->action == MP3_ACT_PLAY) {
    cmd.type = CMD_MP3_PLAY;
    cmd.value = 1;
  } else {
    cmd.type = CMD_MP3_STOP;
    cmd.value = 0;
  }
  send_showduino_command(cmd);
}

void led_slider_event_cb(lv_event_t *e) {
  if (updatingFromStatus) return;
  const uint8_t *linePtr = static_cast<const uint8_t *>(lv_event_get_user_data(e));
  if (!linePtr) return;

  uint16_t brightness = lv_slider_get_value(lv_event_get_target(e));
  ShowduinoCommand cmd{};
  cmd.type = CMD_LED;
  cmd.id = *linePtr;
  cmd.value = brightness;
  send_showduino_command(cmd);
}

void toolbar_event_cb(lv_event_t *e) {
  CommandType type = static_cast<CommandType>((uintptr_t)lv_event_get_user_data(e));

  ShowduinoCommand cmd{};
  cmd.type = type;
  send_showduino_command(cmd);
}

void pair_button_event_cb(lv_event_t *e) {
  (void)e;
  forget_brain_peer();
  update_link_indicator();
}

void settings_brightness_event_cb(lv_event_t *e) {
  if (updatingSettingsUi) return;
  uint16_t level = lv_slider_get_value(lv_event_get_target(e));
  apply_display_brightness(level);
}

void settings_autopair_event_cb(lv_event_t *e) {
  bool enabled = lv_obj_has_state(lv_event_get_target(e), LV_STATE_CHECKED);
  autoPairEnabled = enabled;
  Serial.printf("[ESP-NOW] Auto-pair %s\n", enabled ? "ENABLED" : "DISABLED");
  update_settings_telemetry();
}

void settings_txpower_event_cb(lv_event_t *e) {
  int raw = lv_slider_get_value(lv_event_get_target(e));
  int quantized = (raw / 4) * 4;
  if (quantized < 8) quantized = 8;
  if (quantized > SHOWDUINO_MAX_TX_POWER) quantized = SHOWDUINO_MAX_TX_POWER;
  currentTxPower = quantized;
  updatingSettingsUi = true;
  lv_slider_set_value(lv_event_get_target(e), currentTxPower, LV_ANIM_OFF);
  updatingSettingsUi = false;
  if (espNowReady) {
    esp_wifi_set_max_tx_power(currentTxPower);
  }
  update_settings_telemetry();
}

void settings_ping_event_cb(lv_event_t *e) {
  (void)e;
  ShowduinoCommand cmd{};
  cmd.type = CMD_PING;
  if (send_showduino_command(cmd)) {
    pingPending = true;
    lastPingSendMillis = millis();
    lastPingRoundtrip = 0;
  }
  update_settings_telemetry();
}

void settings_back_event_cb(lv_event_t *e) {
  (void)e;
  detach_keyboard();
  if (screen_main) {
    lv_scr_load_anim(screen_main, LV_SCR_LOAD_ANIM_MOVE_RIGHT, 250, 0, false);
  }
}

void diagnostics_back_event_cb(lv_event_t *e) {
  (void)e;
  if (screen_main) {
    lv_scr_load_anim(screen_main, LV_SCR_LOAD_ANIM_MOVE_RIGHT, 250, 0, false);
  }
}

// ────────────────────────────────────────────────────────────────
//  SETUP
// ────────────────────────────────────────────────────────────────
void setup() {
  Serial.begin(115200);
  delay(250);

  Serial.println();
  Serial.println("╔════════════════════════════════════════════════════════════╗");
  Serial.println("║  SHOWDUINO STUDIO – ESP-NOW Communications Edition v5.0    ║");
  Serial.println("╚════════════════════════════════════════════════════════════╝");

  // Optional: disable brownout during heavy boot
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);

  pinMode(TFT_BL, OUTPUT);
  init_backlight_pwm();

  Serial.println("[BOOT] Initialising RGB panel...");
  rgbpanel = new Arduino_ESP32RGBPanel(
      TFT_DE, TFT_VSYNC, TFT_HSYNC, TFT_PCLK,
      TFT_R1, TFT_R2, TFT_R3, TFT_R4, TFT_R5,
      TFT_G0, TFT_G1, TFT_G2, TFT_G3, TFT_G4, TFT_G5,
      TFT_B1, TFT_B2, TFT_B3, TFT_B4, TFT_B5,
      0, 40, 48, 40, 0, 13, 3, 29, 1, 16000000);

  if (!rgbpanel) {
    Serial.println("[ERROR] ❌ RGB panel allocation failed!");
    while (true) delay(1000);
  }

  gfx = new Arduino_RGB_Display(SCREEN_W, SCREEN_H, rgbpanel);
  if (!gfx) {
    Serial.println("[ERROR] ❌ gfx allocation failed!");
    while (true) delay(1000);
  }

  if (!gfx->begin()) {
    Serial.println("[ERROR] ❌ gfx->begin() failed – check wiring / PSRAM");
    while (true) delay(1000);
  }

  showBootScreen(1, "Display ready");
  Serial.println("[1/6] ✓ Display initialised");
  delay(200);

  Serial.println("[BOOT] Initialising LVGL...");
  if (!init_lvgl()) {
    Serial.println("[ERROR] ❌ LVGL init failed – insufficient PSRAM?");
    while (true) delay(1000);
  }
  showBootScreen(2, "LVGL ready");
  Serial.println("[2/6] ✓ LVGL ready");
  delay(200);

  Serial.println("[BOOT] Initialising GT911 touch...");
  Wire.begin(TOUCH_SDA, TOUCH_SCL, 400000);
  ts_ptr = new TAMC_GT911(TOUCH_SDA, TOUCH_SCL, TOUCH_INT, TOUCH_RST, SCREEN_W, SCREEN_H);
  if (!ts_ptr || !ts_ptr->begin()) {
    Serial.println("[ERROR] ❌ Touch init failed – GT911 not responding");
    while (true) delay(1000);
  }
  showBootScreen(3, "Touch ready");
  Serial.println("[3/6] ✓ Touch ready");
  delay(200);

  Serial.println("[BOOT] Initialising ESP-NOW link...");
  if (!init_esp_now()) {
    showBootScreen(4, "ESP-NOW failed!");
    Serial.println("[ERROR] ❌ ESP-NOW init failed");
    while (true) delay(1000);
  }
  showBootScreen(4, "ESP-NOW ready");
  Serial.println("[4/6] ✓ ESP-NOW ready");
  delay(200);

  showBootScreen(5, "Mounting storage…");
  Serial.println("[BOOT] Mounting storage (SD first)...");
  if (init_storage()) {
    Serial.println("[5/6] ✓ SD storage ready");
  } else {
    Serial.println("[5/6] ⚠️ SD storage unavailable, using RAM-only assets");
  }
  delay(200);

  showBootScreen(6, "Building UI…");
  Serial.println("[BOOT] Launching deferred UI build");
  Serial.println("[6/6] ✓ UI pipeline scheduled");

  systemReady = true;
}

// ────────────────────────────────────────────────────────────────
//  LOOP
// ────────────────────────────────────────────────────────────────
void loop() {
  if (!systemReady) {
    delay(10);
    return;
  }

  static uint32_t lastUiBuild = 0;
  uint32_t now = millis();

  if (!uiCreated && (now - lastUiBuild) > 60) {
    build_ui_incremental();
    lastUiBuild = now;
  }

  static uint32_t lastTick = 0;
  uint32_t tickNow = millis();
  lv_tick_inc(tickNow - lastTick);
  lastTick = tickNow;
  lv_timer_handler();

  handle_status_queue();

  static uint32_t lastLinkRefresh = 0;
  if (now - lastLinkRefresh > 500) {
    update_link_indicator();
    lastLinkRefresh = now;
  }

  delay(5);
}
